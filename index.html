<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multi-Stream Text Editor</title>
    <style>
        body {
            font-family: Georgia, serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        
        .container {
            max-width: 900px;
            margin: 0 auto;
        }
        
        .toolbar {
            background: #f5f5f5;
            padding: 20px 30px;
            font-size: 12px;
            color: #666;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .stream-indicator {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .stream-count {
            padding: 2px 6px;
            background: #3498db;
            color: white;
            border-radius: 3px;
            font-size: 11px;
        }
        
        .controls {
            display: flex;
            gap: 8px;
        }
        
        .btn {
            padding: 10px;
            background: transparent;
            border: none;
            border-radius: 6px;
            font-size: 16px;
            cursor: pointer;
            color: #6c757d;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 36px;
            height: 36px;
        }
        
        .btn:hover {
            background: #f8f9fa;
            color: #495057;
            transform: translateY(-1px);
        }
        
        .btn:active {
            transform: translateY(0);
            background: #e9ecef;
        }
        
        /* Custom tooltip styles */
        .btn {
            position: relative;
        }
        
        .btn::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: -35px;
            left: 50%;
            transform: translateX(-50%);
            background: #343a40;
            color: white;
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 11px;
            font-weight: 500;
            white-space: nowrap;
            opacity: 0;
            visibility: hidden;
            transition: all 0.2s ease;
            pointer-events: none;
            z-index: 1000;
        }
        
        .btn:hover::after {
            opacity: 1;
            visibility: visible;
        }
        
        .content-area {
            background: white;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            padding-bottom: 100px;
            margin-bottom: 20px;
        }
        
        .title-area {
            padding: 80px 100px 20px 100px;
        }
        
        .title-input {
            width: 100%;
            border: none;
            outline: none;
            font-family: Georgia, serif;
            font-size: 28px;
            font-weight: bold;
            text-align: center;
            background: transparent;
            color: #2c3e50;
            padding: 20px 0;
            resize: none;
            overflow: hidden;
        }
        
        .title-input:focus {
            background: rgba(52, 152, 219, 0.02);
        }
        
        .title-input:empty::before {
            content: attr(data-placeholder);
            color: #bdc3c7;
            font-style: italic;
            font-weight: normal;
        }
        
        .editor-area {
            min-height: 500px;
            padding: 0;
            margin: 40px 100px 100px 100px;
        }
        
        .paragraph-group {
            position: relative;
        }
        
        .paragraph-break-header {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 60px 0 40px 0;
            padding: 20px;
            cursor: pointer;
        }
        
        .paragraph-break-symbol {
            font-size: 24px;
            color: #adb5bd;
            font-family: Georgia, serif;
            user-select: none;
            transition: all 0.2s ease;
            position: relative;
        }
        
        .paragraph-delete-indicator {
            position: absolute;
            top: -8px;
            right: -12px;
            background: #dc3545;
            color: white;
            border-radius: 50%;
            width: 16px;
            height: 16px;
            font-size: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transform: scale(0.8);
            transition: all 0.2s ease;
            font-family: monospace;
            font-weight: bold;
        }
        
        .paragraph-break-header:hover .paragraph-break-symbol {
            color: #868e96;
        }
        
        .paragraph-break-header:hover .paragraph-delete-indicator {
            opacity: 1;
            transform: scale(1);
        }
        
        .stream-chunk {
            position: relative;
            margin-bottom: 75px;
        }
        
        .stream-chunk::before {
            content: attr(data-chunk-number);
            position: absolute;
            right: 10px;
            top: 5px;
            font-size: 10px;
            color: #ccc;
            background: white;
            padding: 2px 4px;
            border-radius: 2px;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 10;
        }
        
        .stream-chunk:hover::before {
            opacity: 1;
        }
        
        .stream {
            min-height: 30px;
            padding: 0px 0px 0px 15px;
            margin-bottom: -4px;
            border: none;
            outline: none;
            font-family: Georgia, serif;
            font-size: 16px; 
            line-height: 1.6;
            resize: none;
            background: transparent;
            overflow: hidden;
            white-space: nowrap;
            width: 100%;
        }
        
        .stream:focus {
            background: rgba(52, 152, 219, 0.02);
        }
        
        .stream:empty::before {
            content: attr(data-placeholder);
            color: #999;
            font-style: italic;
        }
        
        .stream-0 { 
            color: black; 
            font-style: normal;
            border-left: 3px solid rgba(233, 233, 233, 0.3);
        }
        .stream-1 { 
            color: black;
            font-style: normal;
            border-left: 3px solid rgba(233, 233, 233, 0.3);
        }
        .stream-2 { 
            color: black; 
            font-style: normal;
            border-left: 3px solid rgba(233, 233, 233, 0.3);
        }
        .stream-3 { 
            color: black; 
            font-style: normal;
            border-left: 3px solid rgba(233, 233, 233, 0.3);
        }
        .stream-4 { 
            color: black; 
            font-style: normal;
            border-left: 3px solid rgba(233, 233, 233, 0.3);
        }
        
        .footer {
            padding: 10px 20px;
            background: #f5f5f5;
            font-size: 11px;
            color: #999;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .footer-counters {
            font-size: 11px;
            color: #999;
        }
        
        /* Hidden measuring element */
        .text-measure {
            position: absolute;
            left: -9999px;
            top: -9999px;
            font-family: Georgia, serif;
            font-size: 16px;
            line-height: 1.6;
            white-space: nowrap;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="toolbar">
            <div></div>
            <div class="controls">
                <button class="btn" id="undoBtn" onclick="undoAction()" data-tooltip="Undo (Cmd+Z)">
                    <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
                        <path d="M3 7v6M3 7l4-4M3 7l4 4M7 7h8" stroke="#74a9d8" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                </button>
                <button class="btn" id="redoBtn" onclick="redoAction()" data-tooltip="Redo (Cmd+Y)">
                    <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
                        <path d="M13 7v6M13 7l-4-4M13 7l-4 4M9 7H1" stroke="#74a9d8" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                </button>
                <button class="btn" onclick="changeStreamCount()" data-tooltip="Change Voices">
                    <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
                        <path d="M2 4h12M2 8h12M2 12h12" stroke="#74a9d8" stroke-width="1.5" stroke-linecap="round"/>
                    </svg>
                </button>
                <button class="btn" onclick="insertParagraphBreak()" data-tooltip="Paragraph Break">
                    <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
                        <path d="M12 2v12M13.5 2H5a2 2 0 0 0-2 2v0a2 2 0 0 0 2 2h3M8 2v12" stroke="#74a9d8" stroke-width="1.5" stroke-linecap="round"/>
                    </svg>
                </button>
                <button class="btn" onclick="saveFile()" data-tooltip="Save Document">
                    <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
                        <path d="M13 15H3a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1h7l4 4v9a1 1 0 0 1-1 1z" stroke="#74a9d8" stroke-width="1.5"/>
                        <path d="M11 1v4H5V1M11 15v-6H5v6" stroke="#74a9d8" stroke-width="1.5"/>
                    </svg>
                </button>
                <button class="btn" onclick="loadFile()" data-tooltip="Load Document">
                    <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
                        <path d="M8 1v10M5 8l3 3 3-3M2 14h12" stroke="#74a9d8" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                </button>
                <button class="btn" onclick="window.open('about.html', '_blank')" data-tooltip="About">
                    <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
                        <circle cx="8" cy="8" r="7" stroke="#74a9d8" stroke-width="1.5"/>
                        <path d="M8 11.5v-3M8 5.5h.01" stroke="#74a9d8" stroke-width="1.5" stroke-linecap="round"/>
                    </svg>
                </button>
                <button class="btn" onclick="exportHtml()" data-tooltip="Export HTML">
                    <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
                        <circle cx="8" cy="8" r="7" stroke="#74a9d8" stroke-width="1.5"/>
                        <path d="M1 8h14" stroke="#74a9d8" stroke-width="1"/>
                        <path d="M2 5.5Q8 4.5 14 5.5M2 10.5Q8 11.5 14 10.5" stroke="#74a9d8" stroke-width="1"/>
                        <path d="M8 1c1.8 0 3.2 3 3.2 7s-1.4 7-3.2 7-3.2-3-3.2-7 1.4-7 3.2-7z" stroke="#74a9d8" stroke-width="1"/>
                    </svg>
                </button>
                <button class="btn" onclick="clearAll()" data-tooltip="Clear All">
                    <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
                        <path d="M3 5v9a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1V5M1 5h14M5 5V3a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v2" stroke="#74a9d8" stroke-width="1.5"/>
                        <path d="M6 8v4M10 8v4" stroke="#74a9d8" stroke-width="1.5" stroke-linecap="round"/>
                    </svg>
                </button>
            </div>
        </div>
        
        <div class="content-area">
            <div class="title-area">
                <div class="title-input" 
                     contenteditable="true" 
                     data-placeholder="Enter your story title..."
                     id="titleInput">
                </div>
            </div>
            
            <div class="editor-area" id="editorArea">
                <!-- Chunks will be added here -->
            </div>
        </div>
        
        <div class="footer">
            <div>Tab for spaces • Shift+Tab to switch voices</div>
            <div class="footer-counters">
                <span id="streamCount">3</span> voices • <span id="chunkCount">1</span> chunks
                <span id="autoSaveIndicator" style="opacity: 0; margin-left: 15px; color: #999;"></span>
            </div>
        </div>
        
        <!-- Hidden element for text measurement -->
        <div class="text-measure" id="textMeasure"></div>
    </div>

    <script>
        // Document model - stores the actual text
        class MultiStreamDocument {
            constructor(streamCount = 3) {
                // Each paragraph group contains all streams for that section
                this.streamGroups = [new Array(streamCount).fill('')];
                this.streamCount = streamCount;
                this.activeStream = 0;
                this.activeCursor = 0;
                this.activeGroup = 0;
                this.title = '';
                this.listeners = [];
                
                // History system for undo/redo
                this.history = [];
                this.historyIndex = -1;
                this.maxHistory = 50; // Limit history to prevent memory issues
                this.isUndoRedoing = false; // Flag to prevent history recording during undo/redo
                this.saveStateTimeout = null; // For debouncing state saves
                this.saveStateDelay = 500; // Save state after 500ms of inactivity
                
                // localStorage auto-save system
                this.autoSaveTimeout = null;
                this.autoSaveDelay = 2000; // Auto-save after 2 seconds of inactivity
                this.lastAutoSaveTime = null;
                
                // Save initial state
                this.saveState();
            }
            
            setStreamText(streamIndex, text, cursorPos = 0, groupIndex = null) {
                const group = groupIndex !== null ? groupIndex : this.activeGroup;
                const oldText = this.streamGroups[group][streamIndex];
                
                // Only save state if the text actually changed
                if (oldText !== text && !this.isUndoRedoing) {
                    this.saveStateDebounced();
                    this.autoSaveDebounced();
                }
                
                this.streamGroups[group][streamIndex] = text;
                this.activeStream = streamIndex;
                this.activeCursor = cursorPos;
                this.activeGroup = group;
                this.notifyChange();
            }
            
            insertText(streamIndex, position, text, groupIndex = null) {
                const group = groupIndex !== null ? groupIndex : this.activeGroup;
                const stream = this.streamGroups[group][streamIndex];
                
                if (!this.isUndoRedoing) {
                    this.saveState();
                    this.autoSaveDebounced();
                }
                
                this.streamGroups[group][streamIndex] = stream.slice(0, position) + text + stream.slice(position);
                this.activeStream = streamIndex;
                this.activeCursor = position + text.length;
                this.activeGroup = group;
                this.notifyChange();
            }
            
            deleteText(streamIndex, start, end, groupIndex = null) {
                const group = groupIndex !== null ? groupIndex : this.activeGroup;
                const stream = this.streamGroups[group][streamIndex];
                
                if (!this.isUndoRedoing) {
                    this.saveState();
                    this.autoSaveDebounced();
                }
                
                this.streamGroups[group][streamIndex] = stream.slice(0, start) + stream.slice(end);
                this.activeStream = streamIndex;
                this.activeCursor = start;
                this.activeGroup = group;
                this.notifyChange();
            }
            
            insertParagraphBreak(chunkIndex) {
                if (!this.isUndoRedoing) {
                    this.saveState();
                    this.autoSaveDebounced();
                }
                
                // Find which group the current chunk belongs to and split there
                let targetGroupIndex = this.activeGroup;
                
                // Split each stream in the current group at the end of the specified chunk
                const currentGroup = this.streamGroups[targetGroupIndex];
                const newGroup = new Array(this.streamCount).fill('');
                
                for (let streamIndex = 0; streamIndex < this.streamCount; streamIndex++) {
                    const stream = currentGroup[streamIndex];
                    const lines = this.breakTextIntoLines(stream);
                    
                    if (chunkIndex < lines.length) {
                        // Split at the end of the chunk
                        const beforeText = lines.slice(0, chunkIndex + 1).join('');
                        const afterText = lines.slice(chunkIndex + 1).join('');
                        
                        currentGroup[streamIndex] = beforeText;
                        newGroup[streamIndex] = afterText;
                    } else {
                        // Chunk doesn't exist in this stream, leave current group unchanged
                        newGroup[streamIndex] = '';
                    }
                }
                
                // Insert the new group after the current one
                this.streamGroups.splice(targetGroupIndex + 1, 0, newGroup);
                this.notifyChange();
            }
            
            removeParagraphBreak(groupIndex) {
                if (!this.isUndoRedoing) {
                    this.saveState();
                    this.autoSaveDebounced();
                }
                
                // Merge the specified group with the next one
                if (groupIndex < this.streamGroups.length - 1) {
                    const currentGroup = this.streamGroups[groupIndex];
                    const nextGroup = this.streamGroups[groupIndex + 1];
                    
                    // First, calculate how many chunks the current group spans
                    const currentGroupLines = currentGroup.map(stream => this.breakTextIntoLines(stream));
                    const currentGroupMaxChunks = Math.max(...currentGroupLines.map(lines => lines.length));
                    
                    // For each stream, pad to align with the chunk boundary
                    for (let streamIndex = 0; streamIndex < this.streamCount; streamIndex++) {
                        const currentText = currentGroup[streamIndex];
                        const nextText = nextGroup[streamIndex];
                        
                        if (nextText.trim() === '') {
                            // Next group has no content for this stream, just keep current
                            continue;
                        }
                        
                        // Calculate how many chunks this stream currently fills
                        const currentLines = this.breakTextIntoLines(currentText);
                        const currentChunks = currentLines.length;
                        
                        // Calculate how much whitespace we need to add to reach the start of the next paragraph
                        let paddingNeeded = '';
                        
                        // If this stream ends before the maximum chunk count, we need to fill the gap
                        const chunksToFill = currentGroupMaxChunks - currentChunks;
                        
                        if (chunksToFill > 0) {
                            // Add spaces to fill complete empty chunks
                            // Each chunk gets filled with a single space (minimal padding)
                            paddingNeeded = ' '.repeat(chunksToFill);
                        }
                        
                        // If the last line of current text isn't empty, add a space separator
                        const lastLine = currentLines[currentLines.length - 1] || '';
                        if (lastLine.trim().length > 0) {
                            paddingNeeded += ' ';
                        }
                        
                        // Combine: current text + padding + next text
                        currentGroup[streamIndex] = currentText + paddingNeeded + nextText;
                    }
                    
                    // Remove the next group
                    this.streamGroups.splice(groupIndex + 1, 1);
                    
                    // Adjust activeGroup if necessary
                    if (this.activeGroup > groupIndex) {
                        this.activeGroup--;
                    }
                    
                    this.notifyChange();
                }
            }
            
            breakTextIntoLines(text) {
                // Use the view's method if available, otherwise return simple split
                if (window.view && window.view.breakTextIntoLines) {
                    return window.view.breakTextIntoLines(text);
                }
                return text ? [text] : [''];
            }
            
            setTitle(title) {
                if (this.title !== title && !this.isUndoRedoing) {
                    this.saveStateDebounced();
                    this.autoSaveDebounced();
                }
                this.title = title;
                // Don't trigger notifyChange for title updates to avoid re-rendering
                // Title changes don't affect the stream layout
            }
            
            onChange(callback) {
                this.listeners.push(callback);
            }
            
            notifyChange() {
                this.listeners.forEach(callback => callback());
            }
            
            // History management methods
            saveStateDebounced() {
                // Clear existing timeout
                if (this.saveStateTimeout) {
                    clearTimeout(this.saveStateTimeout);
                }
                
                // Set new timeout
                this.saveStateTimeout = setTimeout(() => {
                    this.saveState();
                    this.saveStateTimeout = null;
                }, this.saveStateDelay);
            }
            
            saveState() {
                if (this.isUndoRedoing) return; // Don't save state during undo/redo operations
                
                const state = {
                    streamGroups: JSON.parse(JSON.stringify(this.streamGroups)), // Deep copy
                    streamCount: this.streamCount,
                    activeStream: this.activeStream,
                    activeCursor: this.activeCursor,
                    activeGroup: this.activeGroup,
                    title: this.title,
                    timestamp: Date.now()
                };
                
                // Remove any history after current index (when user makes new change after undo)
                if (this.historyIndex < this.history.length - 1) {
                    this.history = this.history.slice(0, this.historyIndex + 1);
                }
                
                // Add new state
                this.history.push(state);
                this.historyIndex = this.history.length - 1;
                
                // Limit history size
                if (this.history.length > this.maxHistory) {
                    this.history.shift();
                    this.historyIndex--;
                }
                
                // Update undo/redo button states
                this.updateUndoRedoButtons();
            }
            
            undo() {
                if (!this.canUndo()) return false;
                
                // Force save any pending changes
                if (this.saveStateTimeout) {
                    clearTimeout(this.saveStateTimeout);
                    this.saveState();
                    this.saveStateTimeout = null;
                }
                
                this.isUndoRedoing = true;
                this.historyIndex--;
                this.restoreState(this.history[this.historyIndex]);
                this.isUndoRedoing = false;
                
                this.updateUndoRedoButtons();
                return true;
            }
            
            redo() {
                if (!this.canRedo()) return false;
                
                // Force save any pending changes
                if (this.saveStateTimeout) {
                    clearTimeout(this.saveStateTimeout);
                    this.saveState();
                    this.saveStateTimeout = null;
                }
                
                this.isUndoRedoing = true;
                this.historyIndex++;
                this.restoreState(this.history[this.historyIndex]);
                this.isUndoRedoing = false;
                
                this.updateUndoRedoButtons();
                return true;
            }
            
            canUndo() {
                return this.historyIndex > 0;
            }
            
            canRedo() {
                return this.historyIndex < this.history.length - 1;
            }
            
            restoreState(state) {
                this.streamGroups = JSON.parse(JSON.stringify(state.streamGroups)); // Deep copy
                this.streamCount = state.streamCount;
                this.activeStream = state.activeStream;
                this.activeCursor = state.activeCursor;
                this.activeGroup = state.activeGroup;
                this.title = state.title;
                
                // Update UI elements
                document.getElementById('titleInput').textContent = this.title;
                document.getElementById('streamCount').textContent = this.streamCount;
                
                // Trigger re-render
                this.notifyChange();
            }
            
            updateUndoRedoButtons() {
                const undoBtn = document.getElementById('undoBtn');
                const redoBtn = document.getElementById('redoBtn');
                
                if (undoBtn) {
                    undoBtn.disabled = !this.canUndo();
                    undoBtn.style.opacity = this.canUndo() ? '1' : '0.5';
                }
                
                if (redoBtn) {
                    redoBtn.disabled = !this.canRedo();
                    redoBtn.style.opacity = this.canRedo() ? '1' : '0.5';
                }
            }
            
            // Auto-save to localStorage methods
            autoSaveDebounced() {
                // Clear existing timeout
                if (this.autoSaveTimeout) {
                    clearTimeout(this.autoSaveTimeout);
                }
                
                // Set new timeout
                this.autoSaveTimeout = setTimeout(() => {
                    this.autoSaveToLocalStorage();
                    this.autoSaveTimeout = null;
                }, this.autoSaveDelay);
            }
            
            autoSaveToLocalStorage() {
                if (this.isUndoRedoing) return; // Don't auto-save during undo/redo operations
                
                try {
                    const content = this.generateSaveFileContent();
                    localStorage.setItem('chora_autosave', content);
                    this.lastAutoSaveTime = new Date();
                    this.updateAutoSaveIndicator();
                } catch (error) {
                    console.warn('Failed to auto-save to localStorage:', error);
                }
            }
            
            generateSaveFileContent() {
                const now = new Date().toISOString().split('T')[0];
                const title = this.title || 'Untitled Story';
                
                // Create the file content (reusing logic from saveFile function)
                let content = `---
streams: ${this.streamCount}
title: "${title}"
created: "${now}"
version: "1.0"
---

`;
                
                // Save each paragraph group
                for (let groupIndex = 0; groupIndex < this.streamGroups.length; groupIndex++) {
                    const group = this.streamGroups[groupIndex];
                    content += `=== Paragraph ${groupIndex + 1} ===\n`;
                    
                    // Save each stream as continuous text (no chunk breakdown)
                    for (let streamIndex = 0; streamIndex < this.streamCount; streamIndex++) {
                        const streamText = group[streamIndex] || '';
                        if (streamText) {
                            content += `Stream ${streamIndex + 1}: ${streamText}\n`;
                        }
                    }
                    content += '\n';
                }
                
                return content;
            }
            
            loadFromLocalStorage() {
                try {
                    const saved = localStorage.getItem('chora_autosave');
                    if (saved && saved.trim()) {
                        return saved;
                    }
                } catch (error) {
                    console.warn('Failed to load from localStorage:', error);
                    // Clear corrupted data
                    this.clearAutoSave();
                }
                return null;
            }
            
            clearAutoSave() {
                try {
                    localStorage.removeItem('chora_autosave');
                    this.lastAutoSaveTime = null;
                    this.updateAutoSaveIndicator();
                } catch (error) {
                    console.warn('Failed to clear auto-save:', error);
                }
            }
            
            updateAutoSaveIndicator() {
                const indicator = document.getElementById('autoSaveIndicator');
                if (indicator) {
                    if (this.lastAutoSaveTime) {
                        const timeStr = this.lastAutoSaveTime.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                        indicator.textContent = `Auto-saved at ${timeStr}`;
                        indicator.style.opacity = '1';
                    } else {
                        indicator.textContent = '';
                        indicator.style.opacity = '0';
                    }
                }
            }
        }
        
        // View model - handles rendering and interaction
        class MultiStreamView {
            constructor(container, document) {
                this.container = container;
                this.document = document;
                this.chunks = [];
                this.maxLineWidth = 0;
                this.isUpdating = false;
                
                this.calculateMaxWidth();
                this.document.onChange(() => this.render());
                
                window.addEventListener('resize', () => {
                    this.calculateMaxWidth();
                    this.render();
                });
            }
            
            calculateMaxWidth() {
                this.maxLineWidth = this.container.clientWidth - 40; // Account for padding
            }
            
            measureTextWidth(text) {
                const measure = document.getElementById('textMeasure');
                measure.textContent = text;
                return measure.offsetWidth;
            }
            
            breakTextIntoLines(text) {
                if (!text) return [''];
                
                const lines = [];
                let currentLine = '';
                let i = 0;
                
                while (i < text.length) {
                    const char = text[i];
                    const testLine = currentLine + char;
                    const width = this.measureTextWidth(testLine);
                    
                    if (width <= this.maxLineWidth) {
                        currentLine = testLine;
                        i++;
                    } else {
                        // Line is too long, need to break
                        if (currentLine === '') {
                            // Single character is too wide, force it anyway
                            currentLine = char;
                            i++;
                        } else {
                            // Try to break at a good point
                            let breakPoint = currentLine.length;
                            
                            // Look backwards for a good break point (space or punctuation)
                            for (let j = currentLine.length - 1; j >= Math.max(0, currentLine.length - 20); j--) {
                                const c = currentLine[j];
                                if (c === ' ' || c === '\t' || c === '-' || c === '.' || c === ',') {
                                    breakPoint = j + 1;
                                    break;
                                }
                            }
                            
                            // If we found a good break point, use it
                            if (breakPoint < currentLine.length) {
                                lines.push(currentLine.substring(0, breakPoint));
                                currentLine = currentLine.substring(breakPoint);
                            } else {
                                // No good break point found, break at current position
                                lines.push(currentLine);
                                currentLine = '';
                            }
                        }
                    }
                }
                
                if (currentLine || lines.length === 0) {
                    lines.push(currentLine);
                }
                
                return lines;
            }
            
            findCursorPosition(streamIndex, absolutePosition, groupIndex) {
                const stream = this.document.streamGroups[groupIndex][streamIndex];
                const lines = this.breakTextIntoLines(stream);
                let currentPos = 0;
                
                for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {
                    const lineLength = lines[lineIndex].length;
                    if (absolutePosition <= currentPos + lineLength) {
                        return {
                            chunkIndex: lineIndex,
                            localPosition: absolutePosition - currentPos,
                            groupIndex: groupIndex
                        };
                    }
                    currentPos += lineLength;
                }
                
                return {
                    chunkIndex: lines.length - 1,
                    localPosition: lines[lines.length - 1]?.length || 0,
                    groupIndex: groupIndex
                };
            }
            
            render() {
                if (this.isUpdating) return;
                this.isUpdating = true;
                
                const activeStream = this.document.activeStream;
                const activeCursor = this.document.activeCursor;
                const activeGroup = this.document.activeGroup;
                
                // Clear and rebuild
                this.container.innerHTML = '';
                
                let totalChunks = 0;
                
                // Render each paragraph group
                for (let groupIndex = 0; groupIndex < this.document.streamGroups.length; groupIndex++) {
                    const group = this.document.streamGroups[groupIndex];
                    
                    // Break all streams in this group into lines
                    const streamLines = group.map(stream => this.breakTextIntoLines(stream));
                    const maxChunks = Math.max(...streamLines.map(lines => lines.length));
                    
                    // Create paragraph group container
                    const paragraphGroup = this.createParagraphGroup(groupIndex);
                    
                    for (let chunkIndex = 0; chunkIndex < maxChunks; chunkIndex++) {
                        const chunk = this.createChunk(totalChunks + chunkIndex + 1, groupIndex, chunkIndex);
                        
                        for (let streamIndex = 0; streamIndex < this.document.streamCount; streamIndex++) {
                            const stream = this.createStream(
                                streamIndex, 
                                chunkIndex, 
                                streamLines[streamIndex][chunkIndex] || '',
                                groupIndex
                            );
                            chunk.appendChild(stream);
                        }
                        
                        paragraphGroup.appendChild(chunk);
                    }
                    
                    this.container.appendChild(paragraphGroup);
                    totalChunks += maxChunks;
                }
                
                // Restore cursor position
                if (activeStream !== null && activeCursor !== null && activeGroup !== null) {
                    const cursorPos = this.findCursorPosition(activeStream, activeCursor, activeGroup);
                    const targetElement = this.container.querySelector(
                        `[data-stream-index="${activeStream}"][data-chunk-index="${cursorPos.chunkIndex}"][data-group-index="${activeGroup}"]`
                    );
                    
                    if (targetElement) {
                        targetElement.focus();
                        this.setCursor(targetElement, cursorPos.localPosition);
                    }
                }
                
                document.getElementById('chunkCount').textContent = totalChunks;
                this.isUpdating = false;
            }
            
            createParagraphGroup(groupIndex) {
                const paragraphGroup = document.createElement('div');
                paragraphGroup.className = 'paragraph-group';
                paragraphGroup.dataset.groupIndex = groupIndex;
                
                // Add visual indicator for paragraph breaks (except for first group)
                if (groupIndex > 0) {
                    const breakHeader = document.createElement('div');
                    breakHeader.className = 'paragraph-break-header';
                    breakHeader.title = 'Click to remove paragraph break';
                    breakHeader.onclick = () => this.removeParagraphBreakHandler(groupIndex);
                    
                    const symbol = document.createElement('span');
                    symbol.className = 'paragraph-break-symbol';
                    symbol.innerHTML = '§'; // Single section symbol - classic typography
                    
                    const deleteIndicator = document.createElement('span');
                    deleteIndicator.className = 'paragraph-delete-indicator';
                    deleteIndicator.innerHTML = '×';
                    
                    symbol.appendChild(deleteIndicator);
                    breakHeader.appendChild(symbol);
                    
                    paragraphGroup.appendChild(breakHeader);
                }
                
                return paragraphGroup;
            }
            
            createChunk(number, groupIndex, localChunkIndex) {
                const chunk = document.createElement('div');
                chunk.className = 'stream-chunk';
                chunk.dataset.chunkNumber = number;
                chunk.dataset.groupIndex = groupIndex;
                chunk.dataset.localChunkIndex = localChunkIndex;
                return chunk;
            }
            
            createStream(streamIndex, chunkIndex, text, groupIndex) {
                const stream = document.createElement('div');
                stream.className = `stream stream-${streamIndex}`;
                stream.contentEditable = true;
                stream.dataset.streamIndex = streamIndex;
                stream.dataset.chunkIndex = chunkIndex;
                stream.dataset.groupIndex = groupIndex;
                stream.textContent = text;
                
                if (streamIndex === 0 && chunkIndex === 0 && groupIndex === 0 && !text) {
                    stream.dataset.placeholder = 'Start writing...';
                }
                
                stream.addEventListener('input', (e) => this.handleInput(e, streamIndex, groupIndex));
                stream.addEventListener('keydown', (e) => this.handleKeyDown(e, streamIndex, chunkIndex, groupIndex));
                stream.addEventListener('focus', (e) => {
                    lastFocusedElement = e.target;
                });
                
                return stream;
            }
            
            handleInput(event, streamIndex, groupIndex) {
                if (this.isUpdating) return;
                
                const element = event.target;
                const cursorPos = this.getCursorPosition(element);
                const chunkIndex = parseInt(element.dataset.chunkIndex);
                
                // Reconstruct the full text for this stream in this group
                const chunks = Array.from(this.container.querySelectorAll(
                    `[data-stream-index="${streamIndex}"][data-group-index="${groupIndex}"]`
                ));
                let absolutePosition = 0;
                
                // Calculate absolute cursor position
                for (let i = 0; i < chunkIndex; i++) {
                    if (chunks[i]) {
                        absolutePosition += chunks[i].textContent.length;
                    }
                }
                absolutePosition += cursorPos;
                
                // Get full text for this stream in this group
                const fullText = chunks.map(chunk => chunk.textContent).join('');
                
                // Update document
                this.document.setStreamText(streamIndex, fullText, absolutePosition, groupIndex);
            }
            
            handleKeyDown(event, streamIndex, chunkIndex, groupIndex) {
                if (event.key === 'Tab') {
                    event.preventDefault();
                    
                    if (event.shiftKey) {
                        // Shift+Tab: switch to previous voice
                        const prevStreamIndex = (streamIndex - 1 + this.document.streamCount) % this.document.streamCount;
                        const prevElement = this.container.querySelector(
                            `[data-stream-index="${prevStreamIndex}"][data-chunk-index="${chunkIndex}"][data-group-index="${groupIndex}"]`
                        );
                        if (prevElement) {
                            prevElement.focus();
                        }
                    } else {
                        // Regular Tab: insert 4 spaces using execCommand for simplicity
                        document.execCommand('insertText', false, '            ');
                    }
                }
            }
            
            getCursorPosition(element) {
                const selection = window.getSelection();
                if (selection.rangeCount === 0) return 0;
                const range = selection.getRangeAt(0);
                return range.startOffset;
            }
            
            setCursor(element, position) {
                const range = document.createRange();
                const selection = window.getSelection();
                
                if (element.firstChild) {
                    range.setStart(element.firstChild, Math.min(position, element.firstChild.textContent.length));
                } else {
                    range.setStart(element, 0);
                }
                
                range.collapse(true);
                selection.removeAllRanges();
                selection.addRange(range);
            }
            
            removeParagraphBreakHandler(groupIndex) {
                // Confirm before removing
                if (confirm('Remove this paragraph break? The content will be merged with the paragraph above.')) {
                    // Remove the paragraph break (merge with previous group)
                    this.document.removeParagraphBreak(groupIndex - 1);
                }
            }
        }
        
        // Initialize the editor
        const doc = new MultiStreamDocument(3);
        const view = new MultiStreamView(document.getElementById('editorArea'), doc);
        
        // Make view available globally for document model to use
        window.view = view;
        
        // Check for auto-saved work on page load
        function checkForAutoSavedWork() {
            const saved = doc.loadFromLocalStorage();
            if (saved) {
                try {
                    parseAndLoadFile(saved);
                    // Update the auto-save indicator to show when it was restored
                    doc.lastAutoSaveTime = new Date();
                    doc.updateAutoSaveIndicator();
                } catch (error) {
                    console.error('Failed to restore auto-saved work:', error);
                    // Clear corrupted auto-save data and continue with fresh document
                    doc.clearAutoSave();
                }
            }
        }
        
        // Run auto-save check after a brief delay to allow page to fully load
        setTimeout(checkForAutoSavedWork, 500);
        
        // Track the last focused text element
        let lastFocusedElement = null;
        
        // Handle title input
        const titleInput = document.getElementById('titleInput');
        titleInput.addEventListener('input', function() {
            doc.setTitle(this.textContent);
        });
        
        titleInput.addEventListener('focus', function() {
            // Don't set lastFocusedElement for title, keep it for stream elements
        });
        
        // Global functions for UI
        function undoAction() {
            doc.undo();
        }
        
        function redoAction() {
            doc.redo();
        }
        
        function insertParagraphBreak() {
            // Use the last focused element or try to find the current one
            const focusedElement = lastFocusedElement || document.activeElement;
            
            if (!focusedElement || !focusedElement.dataset || !focusedElement.dataset.chunkIndex) {
                // If no element is focused, try to use the first text area
                const firstTextArea = document.querySelector('[data-stream-index="0"][data-group-index="0"][data-chunk-index="0"]');
                if (firstTextArea) {
                    lastFocusedElement = firstTextArea;
                } else {
                    alert('Please click in a text area first');
                    return;
                }
            }
            
            const targetElement = lastFocusedElement;
            const chunkIndex = parseInt(targetElement.dataset.chunkIndex);
            const groupIndex = parseInt(targetElement.dataset.groupIndex);
            
            // Set the active group to the current group
            doc.activeGroup = groupIndex;
            
            // Insert paragraph break at the end of this chunk
            doc.insertParagraphBreak(chunkIndex);
        }
        
        function changeStreamCount() {
            const currentCount = doc.streamCount;
            const options = [2, 3, 4, 5];
            
            // Create a simple selection dialog
            const dialog = document.createElement('div');
            dialog.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.5);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 1000;
            `;
            
            const content = document.createElement('div');
            content.style.cssText = `
                background: white;
                padding: 30px;
                border-radius: 8px;
                box-shadow: 0 4px 20px rgba(0,0,0,0.3);
                text-align: center;
                max-width: 400px;
            `;
            
            content.innerHTML = `
                <h3 style="margin: 0 0 20px 0; color: #2c3e50;">Number of Voices</h3>
                <div style="display: flex; gap: 10px; justify-content: center; margin-bottom: 25px;">
                    ${options.map(num => `
                        <button onclick="selectStreamCount(${num})" 
                                style="
                                    padding: 15px 20px;
                                    border: 2px solid ${num === currentCount ? '#3498db' : '#ddd'};
                                    background: ${num === currentCount ? '#3498db' : 'white'};
                                    color: ${num === currentCount ? 'white' : '#666'};
                                    border-radius: 6px;
                                    cursor: pointer;
                                    font-size: 16px;
                                    font-weight: bold;
                                    transition: all 0.2s;
                                "
                                onmouseover="this.style.borderColor='#3498db'; this.style.background='${num === currentCount ? '#3498db' : '#f8f9fa'}';"
                                onmouseout="this.style.borderColor='${num === currentCount ? '#3498db' : '#ddd'}'; this.style.background='${num === currentCount ? '#3498db' : 'white'}';">
                            ${num}
                        </button>
                    `).join('')}
                </div>
                <button onclick="closeStreamDialog()" 
                        style="
                            padding: 10px 20px;
                            border: 1px solid #ddd;
                            background: #f8f9fa;
                            color: #666;
                            border-radius: 4px;
                            cursor: pointer;
                        ">
                    Cancel
                </button>
            `;
            
            dialog.appendChild(content);
            document.body.appendChild(dialog);
            
            // Store dialog reference for cleanup
            window.currentStreamDialog = dialog;
        }
        
        function selectStreamCount(newCount) {
            if (newCount >= 2 && newCount <= 5) {
                const oldGroups = doc.streamGroups.map(group => group.slice());
                doc.streamCount = newCount;
                
                // Resize each group to the new stream count
                doc.streamGroups = oldGroups.map(oldGroup => {
                    const newGroup = new Array(newCount).fill('');
                    // Copy over existing streams
                    for (let i = 0; i < Math.min(oldGroup.length, newCount); i++) {
                        newGroup[i] = oldGroup[i];
                    }
                    return newGroup;
                });
                
                document.getElementById('streamCount').textContent = newCount;
                view.render();
                closeStreamDialog();
            }
        }
        
        function closeStreamDialog() {
            if (window.currentStreamDialog) {
                document.body.removeChild(window.currentStreamDialog);
                window.currentStreamDialog = null;
            }
        }
        
        function saveFile() {
            // Use the new generateSaveFileContent method
            const content = doc.generateSaveFileContent();
            const title = doc.title || 'Untitled Story';
            
            // Download the file
            const blob = new Blob([content], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${title.replace(/[^a-z0-9]/gi, '_')}.txt`;
            a.click();
            URL.revokeObjectURL(url);
            
            // Clear auto-save since user explicitly saved
            doc.clearAutoSave();
        }
        
        function loadFile() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.txt';
            
            input.onchange = function(e) {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        parseAndLoadFile(e.target.result);
                    } catch (error) {
                        alert('Error loading file: ' + error.message);
                    }
                };
                reader.readAsText(file);
            };
            
            input.click();
        }
        
        function parseAndLoadFile(content) {
            const lines = content.split('\n');
            let inMetadata = false;
            let inContent = false;
            let metadata = {};
            let currentParagraph = null;
            let paragraphs = [];
            
            for (const line of lines) {
                const trimmed = line.trim();
                
                if (trimmed === '---') {
                    if (!inMetadata) {
                        inMetadata = true;
                    } else {
                        inMetadata = false;
                        inContent = true;
                    }
                    continue;
                }
                
                if (inMetadata) {
                    const [key, ...valueParts] = trimmed.split(':');
                    if (key && valueParts.length > 0) {
                        const value = valueParts.join(':').trim().replace(/"/g, '');
                        metadata[key.trim()] = value;
                    }
                }
                
                if (inContent) {
                    if (trimmed.startsWith('=== Paragraph')) {
                        // Save previous paragraph if it exists
                        if (currentParagraph) {
                            paragraphs.push(currentParagraph);
                        }
                        // Start new paragraph
                        currentParagraph = {};
                    } else if (trimmed.startsWith('Stream ')) {
                        // Handle both new format (continuous) and old format (chunked)
                        const match = line.match(/^Stream (\d+): (.*)$/);
                        if (match && currentParagraph !== null) {
                            const streamIndex = parseInt(match[1]) - 1;
                            const streamContent = match[2];
                            
                            // If stream already exists in this paragraph, append (for old chunked format)
                            if (currentParagraph[streamIndex]) {
                                currentParagraph[streamIndex] += streamContent;
                            } else {
                                currentParagraph[streamIndex] = streamContent;
                            }
                        }
                    }
                    // Ignore chunk headers (for backward compatibility with old format)
                }
            }
            
            // Handle final paragraph
            if (currentParagraph) {
                paragraphs.push(currentParagraph);
            }
            
            // Reconstruct stream groups
            const streamCount = parseInt(metadata.streams) || 3;
            const newStreamGroups = [];
            
            for (let paragraphIndex = 0; paragraphIndex < paragraphs.length; paragraphIndex++) {
                const paragraph = paragraphs[paragraphIndex];
                const groupStreams = new Array(streamCount).fill('');
                
                // Copy stream content directly (no chunking involved)
                for (let streamIndex = 0; streamIndex < streamCount; streamIndex++) {
                    groupStreams[streamIndex] = paragraph[streamIndex] || '';
                }
                
                newStreamGroups.push(groupStreams);
            }
            
            // Ensure at least one group exists
            if (newStreamGroups.length === 0) {
                newStreamGroups.push(new Array(streamCount).fill(''));
            }
            
            // Update document
            doc.streamCount = streamCount;
            doc.streamGroups = newStreamGroups;
            doc.title = metadata.title || '';
            doc.activeStream = 0;
            doc.activeCursor = 0;
            doc.activeGroup = 0;
            
            // Update title input
            document.getElementById('titleInput').textContent = doc.title;
            
            document.getElementById('streamCount').textContent = streamCount;
            doc.notifyChange();
        }
        
        function exportHtml() {
            const title = doc.title || 'Multi-Voice Story';
            
            // Generate HTML similar to our display format
            let html = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${title}</title>
    <style>
        body {
            font-family: Georgia, serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
            line-height: 1.6;
        }
        
        .container {
            max-width: 900px;
            margin: 0 auto;
            background: white;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            padding-bottom: 100px;
        }
        
        .title-area {
            padding: 80px 100px 20px 100px;
        }
        
        .title {
            font-family: Georgia, serif;
            font-size: 28px;
            font-weight: bold;
            text-align: center;
            color: #2c3e50;
            padding: 20px 0;
        }
        
        .content-area {
            min-height: 500px;
            padding: 0;
            margin: 40px 100px 100px 100px;
        }
        
        .paragraph-group {
            position: relative;
        }
        
        .paragraph-break {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 60px 0 40px 0;
            padding: 20px;
        }
        
        .paragraph-break-symbol {
            font-size: 24px;
            color: #adb5bd;
            font-family: Georgia, serif;
        }
        
        .stream-chunk {
            position: relative;
            margin-bottom: 75px;
        }
        
        .stream {
            min-height: 30px;
            padding: 0px 0px 0px 0px;
            margin-bottom: -7px;
            font-family: Georgia, serif;
            font-size: 16px; 
            line-height: 1.6;
            background: transparent;
            white-space: nowrap;
            width: 100%;
            color: black;
            font-style: normal;
        }
        
        .stream-0, .stream-1, .stream-2, .stream-3, .stream-4 { 
            color: black; 
            font-style: normal;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="title-area">
            <div class="title">${title}</div>
        </div>
        <div class="content-area">
`;
            
            for (let groupIndex = 0; groupIndex < doc.streamGroups.length; groupIndex++) {
                const group = doc.streamGroups[groupIndex];
                
                html += '            <div class="paragraph-group">\n';
                
                if (groupIndex > 0) {
                    html += '                <div class="paragraph-break">\n';
                    html += '                    <span class="paragraph-break-symbol">§</span>\n';
                    html += '                </div>\n';
                }
                
                const streamLines = group.map(stream => view.breakTextIntoLines(stream));
                const maxChunks = Math.max(...streamLines.map(lines => lines.length));
                
                for (let chunkIndex = 0; chunkIndex < maxChunks; chunkIndex++) {
                    html += '                <div class="stream-chunk">\n';
                    for (let streamIndex = 0; streamIndex < doc.streamCount; streamIndex++) {
                        const line = streamLines[streamIndex][chunkIndex] || '';
                        if (line) {  // Export all content, including whitespace-only lines
                            html += `                    <div class="stream stream-${streamIndex}">${line}</div>\n`;
                        }
                    }
                    html += '                </div>\n';
                }
                
                html += '            </div>\n';
            }
            
            html += `        </div>
    </div>
</body>
</html>`;
            
            const blob = new Blob([html], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${title.replace(/[^a-z0-9]/gi, '_')}.html`;
            a.click();
            URL.revokeObjectURL(url);
        }
        
        function exportLatex() {
            const title = doc.title || 'Multi-Voice Story';
            
            let latex = `\\documentclass[11pt]{article}
\\usepackage[margin=1in]{geometry}
\\usepackage{paracol}
\\usepackage{xcolor}

\\title{${title}}
\\author{Your Name}
\\date{}

% Define colors for each voice
\\definecolor{voice1color}{RGB}{139,69,19}
\\definecolor{voice2color}{RGB}{44,62,80}
\\definecolor{voice3color}{RGB}{70,130,180}
\\definecolor{voice4color}{RGB}{39,174,96}
\\definecolor{voice5color}{RGB}{231,76,60}

% Commands for each voice
\\newcommand{\\voiceone}[1]{\\textcolor{voice1color}{\\textit{#1}}}
\\newcommand{\\voicetwo}[1]{\\textcolor{voice2color}{#1}}
\\newcommand{\\voicethree}[1]{\\textcolor{voice3color}{\\textit{#1}}}
\\newcommand{\\voicefour}[1]{\\textcolor{voice4color}{\\textit{#1}}}
\\newcommand{\\voicefive}[1]{\\textcolor{voice5color}{\\textit{#1}}}

\\begin{document}
\\maketitle

\\begin{paracol}{${doc.streamCount}}

`;
            
            for (let groupIndex = 0; groupIndex < doc.streamGroups.length; groupIndex++) {
                const group = doc.streamGroups[groupIndex];
                
                if (groupIndex > 0) {
                    latex += '\n\\switchcolumn*\n\\vspace{20pt}\n\\switchcolumn*\n\n';
                }
                
                const streamLines = group.map(stream => view.breakTextIntoLines(stream));
                const maxChunks = Math.max(...streamLines.map(lines => lines.length));
                
                for (let chunkIndex = 0; chunkIndex < maxChunks; chunkIndex++) {
                    for (let streamIndex = 0; streamIndex < doc.streamCount; streamIndex++) {
                        const line = streamLines[streamIndex][chunkIndex] || '';
                        const commands = ['\\voiceone', '\\voicetwo', '\\voicethree', '\\voicefour', '\\voicefive'];
                        const command = commands[streamIndex] || '\\voicetwo';
                        
                        if (line) {  // Export all content, including whitespace-only lines
                            latex += `${command}{${line.replace(/&/g, '\\&').replace(/#/g, '\\#')}}\n`;
                        }
                        
                        if (streamIndex < doc.streamCount - 1) {
                            latex += '\\switchcolumn\n';
                        }
                    }
                    
                    if (chunkIndex < maxChunks - 1) {
                        latex += '\n\\switchcolumn*\n\n';
                    }
                }
            }
            
            latex += `

\\end{paracol}
\\end{document}`;
            
            const blob = new Blob([latex], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${title.replace(/[^a-z0-9]/gi, '_')}.tex`;
            a.click();
            URL.revokeObjectURL(url);
        }
        
        function clearAll() {
            if (confirm('Clear all content? This cannot be undone.')) {
                doc.streamGroups = [new Array(doc.streamCount).fill('')];
                doc.title = '';
                doc.activeStream = 0;
                doc.activeCursor = 0;
                doc.activeGroup = 0;
                
                // Clear title input
                document.getElementById('titleInput').textContent = '';
                
                // Clear auto-save as well
                doc.clearAutoSave();
                
                doc.notifyChange();
            }
        }
        
        // Add global keyboard shortcuts
        document.addEventListener('keydown', function(event) {
            // Check for Cmd/Ctrl key combinations
            const isCtrlOrCmd = event.ctrlKey || event.metaKey;
            
            if (isCtrlOrCmd && event.key === 'z' && !event.shiftKey) {
                // Cmd+Z / Ctrl+Z - Undo
                event.preventDefault();
                doc.undo();
            } else if (isCtrlOrCmd && (event.key === 'y' || (event.key === 'z' && event.shiftKey))) {
                // Cmd+Y / Ctrl+Y or Cmd+Shift+Z / Ctrl+Shift+Z - Redo
                event.preventDefault();
                doc.redo();
            }
        });
        
        // Initialize
        document.getElementById('streamCount').textContent = doc.streamCount;
        view.render();
    </script>
</body>
</html>
