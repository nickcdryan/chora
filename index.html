<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multi-Stream Text Editor</title>
    <style>
        body {
            font-family: Georgia, serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        
        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 0 20px;
        }
        
        .toolbar {
            background: #f5f5f5;
            padding: 20px 30px;
            font-size: 12px;
            color: #666;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .stream-indicator {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .stream-count {
            padding: 2px 6px;
            background: #3498db;
            color: white;
            border-radius: 3px;
            font-size: 11px;
        }
        
        .controls {
            display: flex;
            gap: 8px;
        }
        
        .btn {
            padding: 10px;
            background: transparent;
            border: none;
            border-radius: 6px;
            font-size: 16px;
            cursor: pointer;
            color: #6c757d;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 36px;
            height: 36px;
        }
        
        .btn:hover {
            background: #f8f9fa;
            color: #495057;
            transform: translateY(-1px);
        }
        
        .btn:active {
            transform: translateY(0);
            background: #e9ecef;
        }
        
        /* Custom tooltip styles */
        .btn {
            position: relative;
        }
        
        .btn::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: -35px;
            left: 50%;
            transform: translateX(-50%);
            background: #343a40;
            color: white;
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 11px;
            font-weight: 500;
            white-space: nowrap;
            opacity: 0;
            visibility: hidden;
            transition: all 0.2s ease;
            pointer-events: none;
            z-index: 1000;
        }
        
        .btn:hover::after {
            opacity: 1;
            visibility: visible;
        }
        
        .content-area {
            background: transparent;
            margin-bottom: 20px;
        }
        
        .pages-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 30px;
            padding: 20px 0;
        }
        
        .page {
            max-width: 900px;
            width: 100%;
            background: white;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            position: relative;
            padding: 0;
            overflow: hidden;
        }
        
        .page-content {
            height: 100%;
            overflow: hidden;
            position: relative;
            box-sizing: border-box;
        }
        
        .title-area {
            padding: 20px 20px 40px 20px;
        }
        
        .title-input {
            width: 100%;
            border: none;
            outline: none;
            font-family: Georgia, serif;
            font-size: 28px;
            font-weight: bold;
            text-align: center;
            background: transparent;
            color: #2c3e50;
            padding: 20px 0;
            resize: none;
            overflow: hidden;
        }
        
        .title-input:focus {
            background: rgba(52, 152, 219, 0.02);
        }
        
        .title-input:empty::before {
            content: attr(data-placeholder);
            color: #bdc3c7;
            font-style: italic;
            font-weight: normal;
        }
        
        .editor-area {
            min-height: 200px;
            padding: 0;
            margin: 20px 0 0 0;
        }
        
        .paragraph-group {
            position: relative;
        }
        
        .paragraph-break-header {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 60px 0 40px 0;
            padding: 20px;
            cursor: pointer;
        }
        
        .paragraph-break-symbol {
            font-size: 24px;
            color: #adb5bd;
            font-family: Georgia, serif;
            user-select: none;
            transition: all 0.2s ease;
            position: relative;
        }
        
        .paragraph-delete-indicator {
            position: absolute;
            top: -8px;
            right: -12px;
            background: #dc3545;
            color: white;
            border-radius: 50%;
            width: 16px;
            height: 16px;
            font-size: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transform: scale(0.8);
            transition: all 0.2s ease;
            font-family: monospace;
            font-weight: bold;
        }
        
        .paragraph-break-header:hover .paragraph-break-symbol {
            color: #868e96;
        }
        
        .paragraph-break-header:hover .paragraph-delete-indicator {
            opacity: 1;
            transform: scale(1);
        }
        
        .stream-chunk {
            position: relative;
            margin-bottom: 75px;
        }
        
        .stream-chunk::before {
            content: attr(data-chunk-number);
            position: absolute;
            right: 10px;
            top: 5px;
            font-size: 10px;
            color: #ccc;
            background: white;
            padding: 2px 4px;
            border-radius: 2px;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 10;
        }
        
        .stream-chunk:hover::before {
            opacity: 1;
        }
        
        .stream {
            min-height: 30px;
            padding: 0px 0px 0px 10px;
            margin-bottom: -4px;
            border: none;
            outline: none;
            font-family: Georgia, serif;
            font-size: 16px; 
            line-height: 1.6;
            resize: none;
            background: transparent;
            overflow: hidden;
            white-space: nowrap;
            width: 100%;
        }
        
        .stream:focus {
            background: rgba(52, 152, 219, 0.02);
        }
        
        .stream:empty::before {
            content: attr(data-placeholder);
            color: #999;
            font-style: italic;
        }
        
        .stream-0 { 
            color: black; 
            font-style: normal;
            border-left: 3px solid rgba(233, 233, 233, 0.3);
            margin-left: -10px;
        }
        .stream-1 { 
            color: black;
            font-style: normal;
            border-left: 3px solid rgba(233, 233, 233, 0.3);
            margin-left: -10px;
        }
        .stream-2 { 
            color: black; 
            font-style: normal;
            border-left: 3px solid rgba(233, 233, 233, 0.3);
            margin-left: -10px;
        }
        .stream-3 { 
            color: black; 
            font-style: normal;
            border-left: 3px solid rgba(233, 233, 233, 0.3);
            margin-left: -10px;
        }
        .stream-4 { 
            color: black; 
            font-style: normal;
            border-left: 3px solid rgba(233, 233, 233, 0.3);
            margin-left: -10px;
        }
        
        .footer {
            padding: 10px 20px;
            background: #f5f5f5;
            font-size: 11px;
            color: #999;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .footer-counters {
            font-size: 11px;
            color: #999;
        }
        
        /* Hidden measuring element */
        .text-measure {
            position: absolute;
            left: -9999px;
            top: -9999px;
            font-family: Georgia, serif;
            font-size: 16px;
            line-height: 1.6;
            white-space: nowrap;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="toolbar">
            <div></div>
            <div class="controls">
                <button class="btn" id="undoBtn" onclick="undoAction()" data-tooltip="Undo (Cmd+Z)">
                    <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
                        <path d="M3 7v6M3 7l4-4M3 7l4 4M7 7h8" stroke="#74a9d8" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                </button>
                <button class="btn" id="redoBtn" onclick="redoAction()" data-tooltip="Redo (Cmd+Y)">
                    <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
                        <path d="M13 7v6M13 7l-4-4M13 7l-4 4M9 7H1" stroke="#74a9d8" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                </button>
                <button class="btn" onclick="changeStreamCount()" data-tooltip="Change Voices">
                    <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
                        <path d="M2 4h12M2 8h12M2 12h12" stroke="#74a9d8" stroke-width="1.5" stroke-linecap="round"/>
                    </svg>
                </button>
                <button class="btn" onclick="insertParagraphBreak()" data-tooltip="Paragraph Break (Ctrl+Shift+P)">
                    <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
                        <path d="M12 2v12M13.5 2H5a2 2 0 0 0-2 2v0a2 2 0 0 0 2 2h3M8 2v12" stroke="#74a9d8" stroke-width="1.5" stroke-linecap="round"/>
                    </svg>
                </button>
                <button class="btn" onclick="saveFile()" data-tooltip="Save Document">
                    <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
                        <path d="M13 15H3a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1h7l4 4v9a1 1 0 0 1-1 1z" stroke="#74a9d8" stroke-width="1.5"/>
                        <path d="M11 1v4H5V1M11 15v-6H5v6" stroke="#74a9d8" stroke-width="1.5"/>
                    </svg>
                </button>
                <button class="btn" onclick="loadFile()" data-tooltip="Load Document">
                    <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
                        <path d="M8 1v10M5 8l3 3 3-3M2 14h12" stroke="#74a9d8" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                </button>
                <button class="btn" onclick="window.open('about.html', '_blank')" data-tooltip="About">
                    <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
                        <circle cx="8" cy="8" r="7" stroke="#74a9d8" stroke-width="1.5"/>
                        <path d="M8 11.5v-3M8 5.5h.01" stroke="#74a9d8" stroke-width="1.5" stroke-linecap="round"/>
                    </svg>
                </button>
                <button class="btn" onclick="exportHtml()" data-tooltip="Export HTML">
                    <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
                        <circle cx="8" cy="8" r="7" stroke="#74a9d8" stroke-width="1.5"/>
                        <path d="M1 8h14" stroke="#74a9d8" stroke-width="1"/>
                        <path d="M2 5.5Q8 4.5 14 5.5M2 10.5Q8 11.5 14 10.5" stroke="#74a9d8" stroke-width="1"/>
                        <path d="M8 1c1.8 0 3.2 3 3.2 7s-1.4 7-3.2 7-3.2-3-3.2-7 1.4-7 3.2-7z" stroke="#74a9d8" stroke-width="1"/>
                    </svg>
                </button>
                <button class="btn" onclick="exportPdf()" data-tooltip="Export PDF">
                    <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
                        <path d="M13 15H3a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1h7l4 4v9a1 1 0 0 1-1 1z" stroke="#74a9d8" stroke-width="1.5"/>
                        <path d="M11 1v4H5V1" stroke="#74a9d8" stroke-width="1.5"/>
                        <path d="M3 8h10M3 11h7" stroke="#74a9d8" stroke-width="1.5"/>
                    </svg>
                </button>
                <button class="btn" onclick="clearAll()" data-tooltip="Clear All">
                    <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
                        <path d="M3 5v9a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1V5M1 5h14M5 5V3a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v2" stroke="#74a9d8" stroke-width="1.5"/>
                        <path d="M6 8v4M10 8v4" stroke="#74a9d8" stroke-width="1.5" stroke-linecap="round"/>
                    </svg>
                </button>
            </div>
        </div>
        
        <div class="content-area">
            <div class="pages-container" id="pagesContainer">
                <!-- Pages will be added here -->
            </div>
        </div>
        
        <div class="footer">
            <div>Tab for spaces • Shift+Tab to switch voices • Return/Shift+Return to switch chunks</div>
            <div class="footer-counters">
                <span id="streamCount">3</span> voices • <span id="chunkCount">1</span> chunks
                <span id="autoSaveIndicator" style="opacity: 0; margin-left: 15px; color: #999;"></span>
            </div>
        </div>
        
        <!-- Hidden element for text measurement -->
        <div class="text-measure" id="textMeasure"></div>
    </div>

    <script>
        // ===== PAGE CONFIGURATION - ADJUST THESE TO CONTROL LAYOUT =====
        const PAGE_CONFIG = {
            HEIGHT: 1400,           // Total page height in pixels
            MARGIN_TOP: 60,        // Top margin/padding
            MARGIN_RIGHT: 80,      // Right margin/padding  
            MARGIN_BOTTOM: 10,     // Bottom margin/padding
            MARGIN_LEFT: 80,       // Left margin/padding
            
            // Calculated values (don't edit these)
            get USABLE_HEIGHT() {
                return this.HEIGHT - this.MARGIN_TOP - this.MARGIN_BOTTOM;
            },
            get CSS_PADDING() {
                return `${this.MARGIN_TOP}px ${this.MARGIN_RIGHT}px ${this.MARGIN_BOTTOM}px ${this.MARGIN_LEFT}px`;
            }
        };
        
        // Apply page configuration to CSS
        function applyPageConfiguration() {
            const style = document.createElement('style');
            style.textContent = `
                .page {
                    height: ${PAGE_CONFIG.HEIGHT}px !important;
                }
                .page-content {
                    padding: ${PAGE_CONFIG.CSS_PADDING} !important;
                }
            `;
            document.head.appendChild(style);
        }
        
        // Document model - stores the actual text
        class MultiStreamDocument {
            constructor(streamCount = 3) {
                // Each paragraph group contains all streams for that section
                this.streamGroups = [new Array(streamCount).fill('')];
                this.streamCount = streamCount;
                this.activeStream = 0;
                this.activeCursor = 0;
                this.activeGroup = 0;
                this.title = '';
                this.listeners = [];
                
                // History system for undo/redo
                this.history = [];
                this.historyIndex = -1;
                this.maxHistory = 50; // Limit history to prevent memory issues
                this.isUndoRedoing = false; // Flag to prevent history recording during undo/redo
                this.saveStateTimeout = null; // For debouncing state saves
                this.saveStateDelay = 500; // Save state after 500ms of inactivity
                
                // localStorage auto-save system
                this.autoSaveTimeout = null;
                this.autoSaveDelay = 2000; // Auto-save after 2 seconds of inactivity
                this.lastAutoSaveTime = null;
                
                // Save initial state
                this.saveState();
            }
            
            setStreamText(streamIndex, text, cursorPos = 0, groupIndex = null) {
                const group = groupIndex !== null ? groupIndex : this.activeGroup;
                const oldText = this.streamGroups[group][streamIndex];
                
                // Only save state if the text actually changed
                if (oldText !== text && !this.isUndoRedoing) {
                    this.saveStateDebounced();
                    this.autoSaveDebounced();
                }
                
                this.streamGroups[group][streamIndex] = text;
                this.activeStream = streamIndex;
                this.activeCursor = cursorPos;
                this.activeGroup = group;
                this.notifyChange();
            }
            
            insertText(streamIndex, position, text, groupIndex = null) {
                const group = groupIndex !== null ? groupIndex : this.activeGroup;
                const stream = this.streamGroups[group][streamIndex];
                
                if (!this.isUndoRedoing) {
                    this.saveState();
                    this.autoSaveDebounced();
                }
                
                this.streamGroups[group][streamIndex] = stream.slice(0, position) + text + stream.slice(position);
                this.activeStream = streamIndex;
                this.activeCursor = position + text.length;
                this.activeGroup = group;
                this.notifyChange();
            }
            
            deleteText(streamIndex, start, end, groupIndex = null) {
                const group = groupIndex !== null ? groupIndex : this.activeGroup;
                const stream = this.streamGroups[group][streamIndex];
                
                if (!this.isUndoRedoing) {
                    this.saveState();
                    this.autoSaveDebounced();
                }
                
                this.streamGroups[group][streamIndex] = stream.slice(0, start) + stream.slice(end);
                this.activeStream = streamIndex;
                this.activeCursor = start;
                this.activeGroup = group;
                this.notifyChange();
            }
            
            insertParagraphBreak(chunkIndex) {
                if (!this.isUndoRedoing) {
                    this.saveState();
                    this.autoSaveDebounced();
                }
                
                // Find which group the current chunk belongs to and split there
                let targetGroupIndex = this.activeGroup;
                
                // Split each stream in the current group at the end of the specified chunk
                const currentGroup = this.streamGroups[targetGroupIndex];
                const newGroup = new Array(this.streamCount).fill('');
                
                for (let streamIndex = 0; streamIndex < this.streamCount; streamIndex++) {
                    const stream = currentGroup[streamIndex];
                    const lines = this.breakTextIntoLines(stream);
                    
                    if (chunkIndex < lines.length) {
                        // Split at the end of the chunk
                        const beforeText = lines.slice(0, chunkIndex + 1).join('');
                        const afterText = lines.slice(chunkIndex + 1).join('');
                        
                        currentGroup[streamIndex] = beforeText;
                        newGroup[streamIndex] = afterText;
                    } else {
                        // Chunk doesn't exist in this stream, leave current group unchanged
                        newGroup[streamIndex] = '';
                    }
                }
                
                // Insert the new group after the current one
                this.streamGroups.splice(targetGroupIndex + 1, 0, newGroup);
                this.notifyChange();
            }
            
            removeParagraphBreak(groupIndex) {
                if (!this.isUndoRedoing) {
                    this.saveState();
                    this.autoSaveDebounced();
                }
                
                // Merge the specified group with the next one
                if (groupIndex < this.streamGroups.length - 1) {
                    const currentGroup = this.streamGroups[groupIndex];
                    const nextGroup = this.streamGroups[groupIndex + 1];
                    
                    // First, calculate how many chunks the current group spans
                    const currentGroupLines = currentGroup.map(stream => this.breakTextIntoLines(stream));
                    const currentGroupMaxChunks = Math.max(...currentGroupLines.map(lines => lines.length));
                    
                    // For each stream, pad to align with the chunk boundary
                    for (let streamIndex = 0; streamIndex < this.streamCount; streamIndex++) {
                        const currentText = currentGroup[streamIndex];
                        const nextText = nextGroup[streamIndex];
                        
                        if (nextText.trim() === '') {
                            // Next group has no content for this stream, just keep current
                            continue;
                        }
                        
                        // Calculate how many chunks this stream currently fills
                        const currentLines = this.breakTextIntoLines(currentText);
                        const currentChunks = currentLines.length;
                        
                        // Calculate how much whitespace we need to add to reach the start of the next paragraph
                        let paddingNeeded = '';
                        
                        // If this stream ends before the maximum chunk count, we need to fill the gap
                        const chunksToFill = currentGroupMaxChunks - currentChunks;
                        
                        if (chunksToFill > 0) {
                            // Add spaces to fill complete empty chunks
                            // Each chunk gets filled with a single space (minimal padding)
                            paddingNeeded = ' '.repeat(chunksToFill);
                        }
                        
                        // If the last line of current text isn't empty, add a space separator
                        const lastLine = currentLines[currentLines.length - 1] || '';
                        if (lastLine.trim().length > 0) {
                            paddingNeeded += ' ';
                        }
                        
                        // Combine: current text + padding + next text
                        currentGroup[streamIndex] = currentText + paddingNeeded + nextText;
                    }
                    
                    // Remove the next group
                    this.streamGroups.splice(groupIndex + 1, 1);
                    
                    // Adjust activeGroup if necessary
                    if (this.activeGroup > groupIndex) {
                        this.activeGroup--;
                    }
                    
                    this.notifyChange();
                }
            }
            
            breakTextIntoLines(text) {
                // Use the view's method if available, otherwise return simple split
                if (window.view && window.view.breakTextIntoLines) {
                    return window.view.breakTextIntoLines(text);
                }
                return text ? [text] : [''];
            }
            
            setTitle(title) {
                if (this.title !== title && !this.isUndoRedoing) {
                    this.saveStateDebounced();
                    this.autoSaveDebounced();
                }
                this.title = title;
                // Don't trigger notifyChange for title updates to avoid re-rendering
                // Title changes don't affect the stream layout
            }
            
            onChange(callback) {
                this.listeners.push(callback);
            }
            
            notifyChange() {
                this.listeners.forEach(callback => callback());
            }
            
            // History management methods
            saveStateDebounced() {
                // Clear existing timeout
                if (this.saveStateTimeout) {
                    clearTimeout(this.saveStateTimeout);
                }
                
                // Set new timeout
                this.saveStateTimeout = setTimeout(() => {
                    this.saveState();
                    this.saveStateTimeout = null;
                }, this.saveStateDelay);
            }
            
            saveState() {
                if (this.isUndoRedoing) return; // Don't save state during undo/redo operations
                
                const state = {
                    streamGroups: JSON.parse(JSON.stringify(this.streamGroups)), // Deep copy
                    streamCount: this.streamCount,
                    activeStream: this.activeStream,
                    activeCursor: this.activeCursor,
                    activeGroup: this.activeGroup,
                    title: this.title,
                    timestamp: Date.now()
                };
                
                // Remove any history after current index (when user makes new change after undo)
                if (this.historyIndex < this.history.length - 1) {
                    this.history = this.history.slice(0, this.historyIndex + 1);
                }
                
                // Add new state
                this.history.push(state);
                this.historyIndex = this.history.length - 1;
                
                // Limit history size
                if (this.history.length > this.maxHistory) {
                    this.history.shift();
                    this.historyIndex--;
                }
                
                // Update undo/redo button states
                this.updateUndoRedoButtons();
            }
            
            undo() {
                if (!this.canUndo()) return false;
                
                // Force save any pending changes
                if (this.saveStateTimeout) {
                    clearTimeout(this.saveStateTimeout);
                    this.saveState();
                    this.saveStateTimeout = null;
                }
                
                this.isUndoRedoing = true;
                this.historyIndex--;
                this.restoreState(this.history[this.historyIndex]);
                this.isUndoRedoing = false;
                
                this.updateUndoRedoButtons();
                return true;
            }
            
            redo() {
                if (!this.canRedo()) return false;
                
                // Force save any pending changes
                if (this.saveStateTimeout) {
                    clearTimeout(this.saveStateTimeout);
                    this.saveState();
                    this.saveStateTimeout = null;
                }
                
                this.isUndoRedoing = true;
                this.historyIndex++;
                this.restoreState(this.history[this.historyIndex]);
                this.isUndoRedoing = false;
                
                this.updateUndoRedoButtons();
                return true;
            }
            
            canUndo() {
                return this.historyIndex > 0;
            }
            
            canRedo() {
                return this.historyIndex < this.history.length - 1;
            }
            
            restoreState(state) {
                this.streamGroups = JSON.parse(JSON.stringify(state.streamGroups)); // Deep copy
                this.streamCount = state.streamCount;
                this.activeStream = state.activeStream;
                this.activeCursor = state.activeCursor;
                this.activeGroup = state.activeGroup;
                this.title = state.title;
                
                // Update UI elements
                document.getElementById('titleInput').textContent = this.title;
                document.getElementById('streamCount').textContent = this.streamCount;
                
                // Trigger re-render
                this.notifyChange();
            }
            
            updateUndoRedoButtons() {
                const undoBtn = document.getElementById('undoBtn');
                const redoBtn = document.getElementById('redoBtn');
                
                if (undoBtn) {
                    undoBtn.disabled = !this.canUndo();
                    undoBtn.style.opacity = this.canUndo() ? '1' : '0.5';
                }
                
                if (redoBtn) {
                    redoBtn.disabled = !this.canRedo();
                    redoBtn.style.opacity = this.canRedo() ? '1' : '0.5';
                }
            }
            
            // Auto-save to localStorage methods
            autoSaveDebounced() {
                // Clear existing timeout
                if (this.autoSaveTimeout) {
                    clearTimeout(this.autoSaveTimeout);
                }
                
                // Set new timeout
                this.autoSaveTimeout = setTimeout(() => {
                    this.autoSaveToLocalStorage();
                    this.autoSaveTimeout = null;
                }, this.autoSaveDelay);
            }
            
            autoSaveToLocalStorage() {
                if (this.isUndoRedoing) return; // Don't auto-save during undo/redo operations
                
                try {
                    const content = this.generateSaveFileContent();
                    localStorage.setItem('chora_autosave', content);
                    this.lastAutoSaveTime = new Date();
                    this.updateAutoSaveIndicator();
                } catch (error) {
                    console.warn('Failed to auto-save to localStorage:', error);
                }
            }
            
            generateSaveFileContent() {
                const now = new Date().toISOString().split('T')[0];
                const title = this.title || 'Untitled Story';
                
                // Create the file content (reusing logic from saveFile function)
                let content = `---
streams: ${this.streamCount}
title: "${title}"
created: "${now}"
version: "1.0"
---

`;
                
                // Save each paragraph group
                for (let groupIndex = 0; groupIndex < this.streamGroups.length; groupIndex++) {
                    const group = this.streamGroups[groupIndex];
                    content += `=== Paragraph ${groupIndex + 1} ===\n`;
                    
                    // Save each stream as continuous text (no chunk breakdown)
                    for (let streamIndex = 0; streamIndex < this.streamCount; streamIndex++) {
                        const streamText = group[streamIndex] || '';
                        if (streamText) {
                            content += `Stream ${streamIndex + 1}: ${streamText}\n`;
                        }
                    }
                    content += '\n';
                }
                
                return content;
            }
            
            loadFromLocalStorage() {
                try {
                    const saved = localStorage.getItem('chora_autosave');
                    if (saved && saved.trim()) {
                        return saved;
                    }
                } catch (error) {
                    console.warn('Failed to load from localStorage:', error);
                    // Clear corrupted data
                    this.clearAutoSave();
                }
                return null;
            }
            
            clearAutoSave() {
                try {
                    localStorage.removeItem('chora_autosave');
                    this.lastAutoSaveTime = null;
                    this.updateAutoSaveIndicator();
                } catch (error) {
                    console.warn('Failed to clear auto-save:', error);
                }
            }
            
            updateAutoSaveIndicator() {
                const indicator = document.getElementById('autoSaveIndicator');
                if (indicator) {
                    if (this.lastAutoSaveTime) {
                        const timeStr = this.lastAutoSaveTime.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                        indicator.textContent = `Auto-saved at ${timeStr}`;
                        indicator.style.opacity = '1';
                    } else {
                        indicator.textContent = '';
                        indicator.style.opacity = '0';
                    }
                }
            }
        }
        
        // View model - handles rendering and interaction
        class MultiStreamView {
            constructor(container, document) {
                this.container = container;
                this.document = document;
                this.chunks = [];
                this.maxLineWidth = 0;
                this.isUpdating = false;
                
                // Page constants - use centralized config
                this.PAGE_HEIGHT = PAGE_CONFIG.HEIGHT;
                this.USABLE_PAGE_HEIGHT = PAGE_CONFIG.USABLE_HEIGHT;
                this.TITLE_HEIGHT = 120;
                this.PARAGRAPH_BREAK_HEIGHT = 120; // Height of paragraph break
                this.STREAM_LINE_HEIGHT = 25.6; // 16px font * 1.6 line-height
                this.CHUNK_MARGIN = 75; // margin-bottom on stream-chunk
                
                this.calculateMaxWidth();
                this.document.onChange(() => this.render());
                
                window.addEventListener('resize', () => {
                    this.calculateMaxWidth();
                    this.render();
                });
            }
            
            calculateMaxWidth() {
                // Calculate based on actual container width
                const container = document.querySelector('.container');
                if (container) {
                    // Get actual container width, accounting for padding
                    const containerWidth = container.offsetWidth - 40; // 40px total padding (20px each side)
                    const pageWidth = Math.min(containerWidth, 900); // Max 900px
                    this.maxLineWidth = pageWidth - (PAGE_CONFIG.MARGIN_LEFT + PAGE_CONFIG.MARGIN_RIGHT);
                } else {
                    // Fallback to original calculation
                    this.maxLineWidth = 900 - 200;
                }
            }
            
            createNewPage() {
                const page = document.createElement('div');
                page.className = 'page';
                
                const pageContent = document.createElement('div');
                pageContent.className = 'page-content';
                
                page.appendChild(pageContent);
                return page;
            }
            

            
            measureTitleHeight() {
                return this.TITLE_HEIGHT;
            }
            
            calculateChunkHeight() {
                // Each chunk contains one line per voice + margins
                const streamHeight = this.document.streamCount * this.STREAM_LINE_HEIGHT;
                return streamHeight + this.CHUNK_MARGIN;
            }
            
            calculateParagraphBreakHeight() {
                return this.PARAGRAPH_BREAK_HEIGHT;
            }
            
            createTitleArea() {
                const titleArea = document.createElement('div');
                titleArea.className = 'title-area';
                
                const titleInput = document.createElement('div');
                titleInput.className = 'title-input';
                titleInput.contentEditable = true;
                titleInput.dataset.placeholder = 'Enter your story title...';
                titleInput.id = 'titleInput';
                titleInput.textContent = this.document.title || '';
                
                // Add event listener for title changes
                titleInput.addEventListener('input', function() {
                    window.view.document.setTitle(this.textContent);
                });
                
                titleArea.appendChild(titleInput);
                return titleArea;
            }
            
            createEditorArea() {
                const editorArea = document.createElement('div');
                editorArea.className = 'editor-area';
                return editorArea;
            }
            
            measureTextWidth(text) {
                const measure = document.getElementById('textMeasure');
                measure.textContent = text;
                return measure.offsetWidth;
            }
            
            breakTextIntoLines(text) {
                if (!text) return [''];
                
                const lines = [];
                let currentLine = '';
                let i = 0;
                
                while (i < text.length) {
                    const char = text[i];
                    const testLine = currentLine + char;
                    const width = this.measureTextWidth(testLine);
                    
                    if (width <= this.maxLineWidth) {
                        currentLine = testLine;
                        i++;
                    } else {
                        // Line is too long, need to break
                        if (currentLine === '') {
                            // Single character is too wide, force it anyway
                            currentLine = char;
                            i++;
                        } else {
                            // Try to break at a good point
                            let breakPoint = currentLine.length;
                            
                            // Look backwards for a good break point (space or punctuation)
                            for (let j = currentLine.length - 1; j >= Math.max(0, currentLine.length - 20); j--) {
                                const c = currentLine[j];
                                if (c === ' ' || c === '\t' || c === '-' || c === '.' || c === ',') {
                                    breakPoint = j + 1;
                                    break;
                                }
                            }
                            
                            // If we found a good break point, use it
                            if (breakPoint < currentLine.length) {
                                const beforeBreak = currentLine.substring(0, breakPoint);
                                let afterBreak = currentLine.substring(breakPoint);
                                
                                // Don't strip any spaces - they're part of the actual text
                                // Just use afterBreak as-is
                                
                                lines.push(beforeBreak);
                                currentLine = afterBreak;
                            } else {
                                // No good break point found, break at current position
                                lines.push(currentLine);
                                currentLine = '';
                            }
                        }
                    }
                }
                
                if (currentLine || lines.length === 0) {
                    lines.push(currentLine);
                }
                
                return lines;
            }
            
            findCursorPosition(streamIndex, absolutePosition, groupIndex) {
                const stream = this.document.streamGroups[groupIndex][streamIndex];
                const lines = this.breakTextIntoLines(stream);
                let currentPos = 0;
                
                for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {
                    const lineLength = lines[lineIndex].length;
                    if (absolutePosition <= currentPos + lineLength) {
                        return {
                            chunkIndex: lineIndex,
                            localPosition: absolutePosition - currentPos,
                            groupIndex: groupIndex
                        };
                    }
                    currentPos += lineLength;
                }
                
                return {
                    chunkIndex: lines.length - 1,
                    localPosition: lines[lines.length - 1]?.length || 0,
                    groupIndex: groupIndex
                };
            }
            
            render() {
                if (this.isUpdating) return;
                this.isUpdating = true;
                
                const activeStream = this.document.activeStream;
                const activeCursor = this.document.activeCursor;
                const activeGroup = this.document.activeGroup;
                
                // Clear and rebuild pages container
                const pagesContainer = document.getElementById('pagesContainer');
                pagesContainer.innerHTML = '';
                
                let currentPage = this.createNewPage();
                let titlePageHeight = 0;
                let totalChunks = 0;
                let isFirstPage = true;
                
                // Track how much height the title uses
                let titleHeightUsed = 0;
                
                // Add title area to first page (always visible for user input)
                const titleHeight = this.measureTitleHeight();
                if (titlePageHeight + titleHeight <= this.PAGE_HEIGHT) {
                    const titleArea = this.createTitleArea();
                    currentPage.querySelector('.page-content').appendChild(titleArea);
                    titlePageHeight += titleHeight;
                    titleHeightUsed = titleHeight;
                }
                
                // Create editor area on current page
                let currentEditorArea = this.createEditorArea();
                currentPage.querySelector('.page-content').appendChild(currentEditorArea);
                
                let currentPageChunks = 0;
                
                // Flatten all chunks first, then paginate
                const allChunks = [];
                
                // Build list of all chunks with their metadata
                for (let groupIndex = 0; groupIndex < this.document.streamGroups.length; groupIndex++) {
                    const group = this.document.streamGroups[groupIndex];
                    
                    // Add paragraph break as a special chunk (except for first group)
                    if (groupIndex > 0) {
                        allChunks.push({
                            type: 'paragraph-break',
                            groupIndex,
                            chunkIndex: -1, // Special marker for paragraph break
                            streamLines: null
                        });
                    }
                    
                    const streamLines = group.map(stream => this.breakTextIntoLines(stream));
                    const maxChunks = Math.max(...streamLines.map(lines => lines.length));
                    
                    for (let chunkIndex = 0; chunkIndex < maxChunks; chunkIndex++) {
                        allChunks.push({
                            type: 'content-chunk',
                            groupIndex,
                            chunkIndex,
                            streamLines
                        });
                    }
                }
                
                // Current paragraph group container
                let currentParagraphGroup = null;
                let lastGroupIndex = -1;
                let currentPageHeight = titleHeightUsed; // Start with title height if present
                
                // Process each chunk
                for (let i = 0; i < allChunks.length; i++) {
                    const chunkData = allChunks[i];
                    
                    // Calculate height of this item
                    let itemHeight = 0;
                    if (chunkData.type === 'paragraph-break') {
                        itemHeight = this.calculateParagraphBreakHeight();
                    } else if (chunkData.type === 'content-chunk') {
                        itemHeight = this.calculateChunkHeight();
                    }
                    
                    // Check if we need a new page
                    if (currentPageHeight + itemHeight > this.USABLE_PAGE_HEIGHT && currentPageHeight > 0) {
                        // Add current page and start new one
                        pagesContainer.appendChild(currentPage);
                        currentPage = this.createNewPage();
                        currentPageHeight = 0;
                        
                        // Create new editor area
                        currentEditorArea = this.createEditorArea();
                        currentPage.querySelector('.page-content').appendChild(currentEditorArea);
                        
                        // Reset paragraph group tracking
                        currentParagraphGroup = null;
                        lastGroupIndex = -1;
                    }
                    
                    if (chunkData.type === 'paragraph-break') {
                        // Create standalone paragraph break
                        const paragraphBreak = this.createStandaloneParagraphBreak(chunkData.groupIndex);
                        currentEditorArea.appendChild(paragraphBreak);
                        currentPageHeight += itemHeight;
                        
                    } else if (chunkData.type === 'content-chunk') {
                        // Create or reuse paragraph group (but without break header since we handle breaks separately)
                        if (chunkData.groupIndex !== lastGroupIndex) {
                            currentParagraphGroup = this.createParagraphGroupWithoutBreak(chunkData.groupIndex);
                            currentEditorArea.appendChild(currentParagraphGroup);
                            lastGroupIndex = chunkData.groupIndex;
                        }
                        
                        // Create the chunk
                        const chunk = this.createChunk(totalChunks + 1, chunkData.groupIndex, chunkData.chunkIndex);
                        
                        for (let streamIndex = 0; streamIndex < this.document.streamCount; streamIndex++) {
                            const stream = this.createStream(
                                streamIndex, 
                                chunkData.chunkIndex, 
                                chunkData.streamLines[streamIndex][chunkData.chunkIndex] || '',
                                chunkData.groupIndex
                            );
                            chunk.appendChild(stream);
                        }
                        
                        currentParagraphGroup.appendChild(chunk);
                        currentPageHeight += itemHeight;
                        totalChunks++;
                    }
                }
                
                // Add the final page
                pagesContainer.appendChild(currentPage);
                
                // Restore cursor position
                if (activeStream !== null && activeCursor !== null && activeGroup !== null) {
                    const cursorPos = this.findCursorPosition(activeStream, activeCursor, activeGroup);
                    const targetElement = pagesContainer.querySelector(
                        `[data-stream-index="${activeStream}"][data-chunk-index="${cursorPos.chunkIndex}"][data-group-index="${activeGroup}"]`
                    );
                    
                    if (targetElement) {
                        targetElement.focus();
                        this.setCursor(targetElement, cursorPos.localPosition);
                    }
                }
                
                document.getElementById('chunkCount').textContent = totalChunks;
                this.isUpdating = false;
            }
            
            createParagraphGroup(groupIndex) {
                const paragraphGroup = document.createElement('div');
                paragraphGroup.className = 'paragraph-group';
                paragraphGroup.dataset.groupIndex = groupIndex;
                
                // Add visual indicator for paragraph breaks (except for first group)
                if (groupIndex > 0) {
                    const breakHeader = document.createElement('div');
                    breakHeader.className = 'paragraph-break-header';
                    breakHeader.title = 'Click to remove paragraph break';
                    breakHeader.onclick = () => this.removeParagraphBreakHandler(groupIndex);
                    
                    const symbol = document.createElement('span');
                    symbol.className = 'paragraph-break-symbol';
                    symbol.innerHTML = '§'; // Single section symbol - classic typography
                    
                    const deleteIndicator = document.createElement('span');
                    deleteIndicator.className = 'paragraph-delete-indicator';
                    deleteIndicator.innerHTML = '×';
                    
                    symbol.appendChild(deleteIndicator);
                    breakHeader.appendChild(symbol);
                    
                    paragraphGroup.appendChild(breakHeader);
                }
                
                return paragraphGroup;
            }
            
            createParagraphGroupWithoutBreak(groupIndex) {
                const paragraphGroup = document.createElement('div');
                paragraphGroup.className = 'paragraph-group';
                paragraphGroup.dataset.groupIndex = groupIndex;
                return paragraphGroup;
            }
            
            createStandaloneParagraphBreak(groupIndex) {
                const breakHeader = document.createElement('div');
                breakHeader.className = 'paragraph-break-header';
                breakHeader.title = 'Click to remove paragraph break';
                breakHeader.onclick = () => this.removeParagraphBreakHandler(groupIndex);
                
                const symbol = document.createElement('span');
                symbol.className = 'paragraph-break-symbol';
                symbol.innerHTML = '§'; // Single section symbol - classic typography
                
                const deleteIndicator = document.createElement('span');
                deleteIndicator.className = 'paragraph-delete-indicator';
                deleteIndicator.innerHTML = '×';
                
                symbol.appendChild(deleteIndicator);
                breakHeader.appendChild(symbol);
                
                return breakHeader;
            }
            
            createChunk(number, groupIndex, localChunkIndex) {
                const chunk = document.createElement('div');
                chunk.className = 'stream-chunk';
                chunk.dataset.chunkNumber = number;
                chunk.dataset.groupIndex = groupIndex;
                chunk.dataset.localChunkIndex = localChunkIndex;
                return chunk;
            }
            
            createStream(streamIndex, chunkIndex, text, groupIndex) {
                const stream = document.createElement('div');
                stream.className = `stream stream-${streamIndex}`;
                stream.dataset.streamIndex = streamIndex;
                stream.dataset.chunkIndex = chunkIndex;
                stream.dataset.groupIndex = groupIndex;
                stream.textContent = text;
                stream.style.cursor = 'text';
                stream.style.minHeight = '1.6em'; // Ensure clickable area
                
                if (streamIndex === 0 && chunkIndex === 0 && groupIndex === 0 && !text) {
                    stream.dataset.placeholder = 'Start writing...';
                }
                
                // Make it clickable to start editing
                stream.addEventListener('click', (e) => {
                    this.startInlineEditing(streamIndex, chunkIndex, groupIndex, e);
                });
                
                return stream;
            }
            
            startInlineEditing(streamIndex, chunkIndex, groupIndex, event) {
                // Prevent multiple editors
                if (document.querySelector('.inline-editor')) return;
                
                const clickedElement = event.target;
                const fullText = this.document.streamGroups[groupIndex][streamIndex];
                
                // Create textarea that perfectly overlays the clicked element
                const textarea = document.createElement('textarea');
                textarea.className = 'inline-editor';
                textarea.value = fullText;
                
                // Match the exact styling of the chunk
                const computedStyle = window.getComputedStyle(clickedElement);
                textarea.style.position = 'absolute';
                textarea.style.fontFamily = computedStyle.fontFamily;
                textarea.style.fontSize = computedStyle.fontSize;
                textarea.style.lineHeight = computedStyle.lineHeight;
                textarea.style.color = computedStyle.color;
                textarea.style.backgroundColor = computedStyle.backgroundColor;
                textarea.style.border = '2px solid #3498db';
                textarea.style.borderRadius = '4px';
                textarea.style.padding = computedStyle.padding;
                textarea.style.margin = '0';
                textarea.style.resize = 'none';
                textarea.style.outline = 'none';
                textarea.style.zIndex = '1000';
                textarea.style.width = clickedElement.offsetWidth + 'px';
                textarea.style.minHeight = clickedElement.offsetHeight + 'px';
                
                // Position exactly over the clicked element
                const rect = clickedElement.getBoundingClientRect();
                const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;
                const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
                textarea.style.left = (rect.left + scrollLeft - 2) + 'px'; // Account for border
                textarea.style.top = (rect.top + scrollTop - 2) + 'px';
                
                // Hide the original element
                clickedElement.style.opacity = '0.1';
                
                // Calculate initial cursor position
                const lines = this.breakTextIntoLines(fullText);
                let cursorPos = 0;
                for (let i = 0; i < chunkIndex; i++) {
                    cursorPos += (lines[i] || '').length;
                }
                
                document.body.appendChild(textarea);
                textarea.focus();
                textarea.setSelectionRange(cursorPos, cursorPos);
                
                // Handle input changes
                const handleInput = () => {
                    this.document.setStreamText(streamIndex, textarea.value, 
                                               textarea.selectionStart, groupIndex);
                };
                
                textarea.addEventListener('input', handleInput);
                
                // Handle keyboard shortcuts
                textarea.addEventListener('keydown', (e) => {
                    if (e.key === 'Tab') {
                        e.preventDefault();
                        if (e.shiftKey) {
                            // Switch streams
                            const nextStreamIndex = (streamIndex + 1) % this.document.streamCount;
                            cleanup();
                            setTimeout(() => {
                                const nextElement = document.querySelector(
                                    `[data-stream-index="${nextStreamIndex}"][data-chunk-index="${chunkIndex}"][data-group-index="${groupIndex}"]`
                                );
                                if (nextElement) nextElement.click();
                            }, 10);
                        } else {
                            // Insert spaces
                            const start = textarea.selectionStart;
                            const end = textarea.selectionEnd;
                            const spaces = '    ';
                            textarea.value = textarea.value.substring(0, start) + spaces + textarea.value.substring(end);
                            textarea.setSelectionRange(start + spaces.length, start + spaces.length);
                            handleInput();
                        }
                    } else if (e.key === 'Escape') {
                        cleanup();
                    }
                });
                
                // Cleanup function
                const cleanup = () => {
                    textarea.removeEventListener('input', handleInput);
                    clickedElement.style.opacity = '';
                    if (document.body.contains(textarea)) {
                        document.body.removeChild(textarea);
                    }
                };
                
                textarea.addEventListener('blur', cleanup);
            }
            
            handleKeyDown(event, streamIndex, chunkIndex, groupIndex) {
                if (event.key === 'Tab') {
                    event.preventDefault();
                    
                    if (event.shiftKey) {
                        // Shift+Tab: switch to next voice (cycling down)
                        const nextStreamIndex = (streamIndex + 1) % this.document.streamCount;
                        const pagesContainer = document.getElementById('pagesContainer');
                        const nextElement = pagesContainer.querySelector(
                            `[data-stream-index="${nextStreamIndex}"][data-chunk-index="${chunkIndex}"][data-group-index="${groupIndex}"]`
                        );
                        if (nextElement) {
                            nextElement.focus();
                        }
                    } else {
                        // Regular Tab: insert 4 spaces using execCommand
                        document.execCommand('insertText', false, '    ');
                    }
                } else if (event.key === 'Enter') {
                    event.preventDefault();
                    
                    if (event.shiftKey) {
                        // Shift+Enter: move to previous chunk in the same stream
                        let prevElement = null;
                        const pagesContainer = document.getElementById('pagesContainer');
                        
                        if (chunkIndex > 0) {
                            // Try to find previous chunk in the same group
                            const prevChunkIndex = chunkIndex - 1;
                            prevElement = pagesContainer.querySelector(
                                `[data-stream-index="${streamIndex}"][data-chunk-index="${prevChunkIndex}"][data-group-index="${groupIndex}"]`
                            );
                        } else {
                            // If at chunk 0, try to find the last chunk of the same stream in the previous group
                            const prevGroupIndex = groupIndex - 1;
                            if (prevGroupIndex >= 0) {
                                const prevGroupChunks = pagesContainer.querySelectorAll(
                                    `[data-stream-index="${streamIndex}"][data-group-index="${prevGroupIndex}"]`
                                );
                                if (prevGroupChunks.length > 0) {
                                    prevElement = prevGroupChunks[prevGroupChunks.length - 1];
                                }
                            }
                        }
                        
                        if (prevElement) {
                            prevElement.focus();
                            this.setCursor(prevElement, 0);
                        }
                    } else {
                        // Regular Enter: move to next chunk in the same stream
                        const nextChunkIndex = chunkIndex + 1;
                        let nextElement = null;
                        const pagesContainer = document.getElementById('pagesContainer');
                        
                        nextElement = pagesContainer.querySelector(
                            `[data-stream-index="${streamIndex}"][data-chunk-index="${nextChunkIndex}"][data-group-index="${groupIndex}"]`
                        );
                        
                        if (!nextElement) {
                            const nextGroupIndex = groupIndex + 1;
                            nextElement = pagesContainer.querySelector(
                                `[data-stream-index="${streamIndex}"][data-chunk-index="0"][data-group-index="${nextGroupIndex}"]`
                            );
                        }
                        
                        if (nextElement) {
                            nextElement.focus();
                            this.setCursor(nextElement, 0);
                        }
                    }
                }
            }
            
            getCursorPosition(element) {
                const selection = window.getSelection();
                if (selection.rangeCount === 0) return 0;
                const range = selection.getRangeAt(0);
                return range.startOffset;
            }
            
            setCursor(element, position) {
                const range = document.createRange();
                const selection = window.getSelection();
                
                if (element.firstChild) {
                    range.setStart(element.firstChild, Math.min(position, element.firstChild.textContent.length));
                } else {
                    range.setStart(element, 0);
                }
                
                range.collapse(true);
                selection.removeAllRanges();
                selection.addRange(range);
            }
            
            removeParagraphBreakHandler(groupIndex) {
                // Remove the paragraph break (merge with previous group)
                this.document.removeParagraphBreak(groupIndex - 1);
            }
        }
        
        // Initialize the editor
        const doc = new MultiStreamDocument(3);
        const view = new MultiStreamView(document.getElementById('pagesContainer'), doc);
        
        // Make view available globally for document model to use
        window.view = view;
        
        // Check for auto-saved work on page load
        function checkForAutoSavedWork() {
            const saved = doc.loadFromLocalStorage();
            if (saved) {
                try {
                    parseAndLoadFile(saved);
                    // Update the auto-save indicator to show when it was restored
                    doc.lastAutoSaveTime = new Date();
                    doc.updateAutoSaveIndicator();
                } catch (error) {
                    console.error('Failed to restore auto-saved work:', error);
                    // Clear corrupted auto-save data and continue with fresh document
                    doc.clearAutoSave();
                }
            }
        }
        
        // Run auto-save check after a brief delay to allow page to fully load
        setTimeout(checkForAutoSavedWork, 500);
        
        // Track the last focused text element
        let lastFocusedElement = null;
        
        // Title input is now handled dynamically in createTitleArea()
        
        // Global functions for UI
        function undoAction() {
            doc.undo();
        }
        
        function redoAction() {
            doc.redo();
        }
        
        function insertParagraphBreak() {
            // Use the last focused element or try to find the current one
            const focusedElement = lastFocusedElement || document.activeElement;
            
            if (!focusedElement || !focusedElement.dataset || !focusedElement.dataset.chunkIndex) {
                // If no element is focused, try to use the first text area
                const firstTextArea = document.querySelector('[data-stream-index="0"][data-group-index="0"][data-chunk-index="0"]');
                if (firstTextArea) {
                    lastFocusedElement = firstTextArea;
                } else {
                    alert('Please click in a text area first');
                    return;
                }
            }
            
            const targetElement = lastFocusedElement;
            const chunkIndex = parseInt(targetElement.dataset.chunkIndex);
            const groupIndex = parseInt(targetElement.dataset.groupIndex);
            const streamIndex = parseInt(targetElement.dataset.streamIndex);
            
            // Set the active group to the current group
            doc.activeGroup = groupIndex;
            
            // Insert paragraph break at the end of this chunk
            doc.insertParagraphBreak(chunkIndex);
            
            // After render completes, focus the first chunk of the new paragraph group
            setTimeout(() => {
                const pagesContainer = document.getElementById('pagesContainer');
                const newGroupFirstChunk = pagesContainer.querySelector(
                    `[data-stream-index="${streamIndex}"][data-chunk-index="0"][data-group-index="${groupIndex + 1}"]`
                );
                
                if (newGroupFirstChunk) {
                    newGroupFirstChunk.focus();
                    view.setCursor(newGroupFirstChunk, 0);
                    lastFocusedElement = newGroupFirstChunk;
                    
                    // Update document's active position to match
                    doc.activeGroup = groupIndex + 1;
                    doc.activeStream = streamIndex;
                    doc.activeCursor = 0;
                }
            }, 10);
        }
        
        function changeStreamCount() {
            const currentCount = doc.streamCount;
            const options = [2, 3, 4, 5];
            
            // Create a simple selection dialog
            const dialog = document.createElement('div');
            dialog.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.5);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 1000;
            `;
            
            const content = document.createElement('div');
            content.style.cssText = `
                background: white;
                padding: 30px;
                border-radius: 8px;
                box-shadow: 0 4px 20px rgba(0,0,0,0.3);
                text-align: center;
                max-width: 400px;
            `;
            
            content.innerHTML = `
                <h3 style="margin: 0 0 20px 0; color: #2c3e50;">Number of Voices</h3>
                <div style="display: flex; gap: 10px; justify-content: center; margin-bottom: 25px;">
                    ${options.map(num => `
                        <button onclick="selectStreamCount(${num})" 
                                style="
                                    padding: 15px 20px;
                                    border: 2px solid ${num === currentCount ? '#3498db' : '#ddd'};
                                    background: ${num === currentCount ? '#3498db' : 'white'};
                                    color: ${num === currentCount ? 'white' : '#666'};
                                    border-radius: 6px;
                                    cursor: pointer;
                                    font-size: 16px;
                                    font-weight: bold;
                                    transition: all 0.2s;
                                "
                                onmouseover="this.style.borderColor='#3498db'; this.style.background='${num === currentCount ? '#3498db' : '#f8f9fa'}';"
                                onmouseout="this.style.borderColor='${num === currentCount ? '#3498db' : '#ddd'}'; this.style.background='${num === currentCount ? '#3498db' : 'white'}';">
                            ${num}
                        </button>
                    `).join('')}
                </div>
                <button onclick="closeStreamDialog()" 
                        style="
                            padding: 10px 20px;
                            border: 1px solid #ddd;
                            background: #f8f9fa;
                            color: #666;
                            border-radius: 4px;
                            cursor: pointer;
                        ">
                    Cancel
                </button>
            `;
            
            dialog.appendChild(content);
            document.body.appendChild(dialog);
            
            // Store dialog reference for cleanup
            window.currentStreamDialog = dialog;
        }
        
        function selectStreamCount(newCount) {
            if (newCount >= 2 && newCount <= 5) {
                const oldGroups = doc.streamGroups.map(group => group.slice());
                doc.streamCount = newCount;
                
                // Resize each group to the new stream count
                doc.streamGroups = oldGroups.map(oldGroup => {
                    const newGroup = new Array(newCount).fill('');
                    // Copy over existing streams
                    for (let i = 0; i < Math.min(oldGroup.length, newCount); i++) {
                        newGroup[i] = oldGroup[i];
                    }
                    return newGroup;
                });
                
                document.getElementById('streamCount').textContent = newCount;
                view.render();
                closeStreamDialog();
            }
        }
        
        function closeStreamDialog() {
            if (window.currentStreamDialog) {
                document.body.removeChild(window.currentStreamDialog);
                window.currentStreamDialog = null;
            }
        }
        
        function saveFile() {
            // Use the new generateSaveFileContent method
            const content = doc.generateSaveFileContent();
            const title = doc.title || 'Untitled Story';
            
            // Download the file
            const blob = new Blob([content], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${title.replace(/[^a-z0-9]/gi, '_')}.txt`;
            a.click();
            URL.revokeObjectURL(url);
            
            // Clear auto-save since user explicitly saved
            doc.clearAutoSave();
        }
        
        function loadFile() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.txt';
            
            input.onchange = function(e) {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        parseAndLoadFile(e.target.result);
                    } catch (error) {
                        alert('Error loading file: ' + error.message);
                    }
                };
                reader.readAsText(file);
            };
            
            input.click();
        }
        
        function parseAndLoadFile(content) {
            const lines = content.split('\n');
            let inMetadata = false;
            let inContent = false;
            let metadata = {};
            let currentParagraph = null;
            let paragraphs = [];
            
            for (const line of lines) {
                const trimmed = line.trim();
                
                if (trimmed === '---') {
                    if (!inMetadata) {
                        inMetadata = true;
                    } else {
                        inMetadata = false;
                        inContent = true;
                    }
                    continue;
                }
                
                if (inMetadata) {
                    const [key, ...valueParts] = trimmed.split(':');
                    if (key && valueParts.length > 0) {
                        const value = valueParts.join(':').trim().replace(/"/g, '');
                        metadata[key.trim()] = value;
                    }
                }
                
                if (inContent) {
                    if (trimmed.startsWith('=== Paragraph')) {
                        // Save previous paragraph if it exists
                        if (currentParagraph) {
                            paragraphs.push(currentParagraph);
                        }
                        // Start new paragraph
                        currentParagraph = {};
                    } else if (trimmed.startsWith('Stream ')) {
                        // Handle both new format (continuous) and old format (chunked)
                        const match = line.match(/^Stream (\d+): (.*)$/);
                        if (match && currentParagraph !== null) {
                            const streamIndex = parseInt(match[1]) - 1;
                            const streamContent = match[2];
                            
                            // If stream already exists in this paragraph, append (for old chunked format)
                            if (currentParagraph[streamIndex]) {
                                currentParagraph[streamIndex] += streamContent;
                            } else {
                                currentParagraph[streamIndex] = streamContent;
                            }
                        }
                    }
                    // Ignore chunk headers (for backward compatibility with old format)
                }
            }
            
            // Handle final paragraph
            if (currentParagraph) {
                paragraphs.push(currentParagraph);
            }
            
            // Reconstruct stream groups
            const streamCount = parseInt(metadata.streams) || 3;
            const newStreamGroups = [];
            
            for (let paragraphIndex = 0; paragraphIndex < paragraphs.length; paragraphIndex++) {
                const paragraph = paragraphs[paragraphIndex];
                const groupStreams = new Array(streamCount).fill('');
                
                // Copy stream content directly (no chunking involved)
                for (let streamIndex = 0; streamIndex < streamCount; streamIndex++) {
                    groupStreams[streamIndex] = paragraph[streamIndex] || '';
                }
                
                newStreamGroups.push(groupStreams);
            }
            
            // Ensure at least one group exists
            if (newStreamGroups.length === 0) {
                newStreamGroups.push(new Array(streamCount).fill(''));
            }
            
            // Update document
            doc.streamCount = streamCount;
            doc.streamGroups = newStreamGroups;
            doc.title = metadata.title || '';
            doc.activeStream = 0;
            doc.activeCursor = 0;
            doc.activeGroup = 0;
            
            // Update title input
            document.getElementById('titleInput').textContent = doc.title;
            
            document.getElementById('streamCount').textContent = streamCount;
            doc.notifyChange();
        }
        
        function exportHtml() {
            const title = doc.title || 'Multi-Voice Story';
            
            // Generate HTML with page breaks matching the editor's pagination
            let html = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${title}</title>
    <style>
        body {
            font-family: Georgia, serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
            line-height: 1.6;
        }
        
        .pages-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 30px;
            padding: 20px 0;
        }
        
        .page {
            max-width: 900px;
            width: 100%;
            background: white;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            position: relative;
            padding: 0;
            overflow: visible;
            min-height: ${PAGE_CONFIG.HEIGHT}px;
        }
        
        .page-content {
            min-height: 100%;
            overflow: visible;
            position: relative;
            box-sizing: border-box;
            padding: ${PAGE_CONFIG.CSS_PADDING};
        }
        
        .title-area {
            padding: 20px 20px 40px 20px;
        }
        
        .title {
            font-family: Georgia, serif;
            font-size: 28px;
            font-weight: bold;
            text-align: center;
            color: #2c3e50;
            padding: 20px 0;
        }
        
        .editor-area {
            min-height: 200px;
            padding: 0;
            margin: 20px 0 0 0;
        }
        
        .paragraph-group {
            position: relative;
        }
        
        .paragraph-break-header {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 60px 0 40px 0;
            padding: 20px;
        }
        
        .paragraph-break-symbol {
            font-size: 24px;
            color: #adb5bd;
            font-family: Georgia, serif;
        }
        
        .stream-chunk {
            position: relative;
            margin-bottom: 75px;
        }
        
        .stream {
            min-height: 30px;
            padding: 0px 0px 0px 0px;
            margin-bottom: -4px;
            font-family: Georgia, serif;
            font-size: 16px; 
            line-height: 1.6;
            background: transparent;
            white-space: nowrap;
            width: 100%;
            color: black;
            font-style: normal;
        }
        
        .stream-0, .stream-1, .stream-2, .stream-3, .stream-4 { 
            color: black; 
            font-style: normal;
        }
        
        @media print {
            .page {
                page-break-after: always;
                box-shadow: none;
                margin: 0;
                height: ${PAGE_CONFIG.HEIGHT}px;
                overflow: hidden;
            }
            .page-content {
                height: 100%;
                overflow: hidden;
            }
            .pages-container {
                gap: 0;
            }
            body {
                background: white;
                padding: 0;
            }
        }
    </style>
</head>
<body>
    <div class="pages-container">
`;
            
            // Use the same pagination logic as the view's render method
            let currentPageContent = '';
            let titlePageHeight = 0;
            let isFirstPage = true;
            let titleHeightUsed = 0;
            
            // Start first page
            html += '        <div class="page">\n';
            html += '            <div class="page-content">\n';
            
            // Add title to first page if it exists
            if (doc.title && doc.title.trim()) {
                const titleHeight = view.measureTitleHeight();
                if (titlePageHeight + titleHeight <= PAGE_CONFIG.HEIGHT) {
                    html += '                <div class="title-area">\n';
                    html += `                    <div class="title">${title}</div>\n`;
                    html += '                </div>\n';
                    titlePageHeight += titleHeight;
                    titleHeightUsed = titleHeight;
                }
            }
            
            // Add editor area
            html += '                <div class="editor-area">\n';
            
            // Build list of all chunks with their metadata (same as render method)
            const allChunks = [];
            
            for (let groupIndex = 0; groupIndex < doc.streamGroups.length; groupIndex++) {
                const group = doc.streamGroups[groupIndex];
                
                // Add paragraph break as a special chunk (except for first group)
                if (groupIndex > 0) {
                    allChunks.push({
                        type: 'paragraph-break',
                        groupIndex,
                        chunkIndex: -1,
                        streamLines: null
                    });
                }
                
                const streamLines = group.map(stream => view.breakTextIntoLines(stream));
                const maxChunks = Math.max(...streamLines.map(lines => lines.length));
                
                for (let chunkIndex = 0; chunkIndex < maxChunks; chunkIndex++) {
                    allChunks.push({
                        type: 'content-chunk',
                        groupIndex,
                        chunkIndex,
                        streamLines
                    });
                }
            }
            
            // Process each chunk with pagination
            let currentParagraphGroup = null;
            let lastGroupIndex = -1;
            let currentPageHeight = titleHeightUsed;
            
            for (let i = 0; i < allChunks.length; i++) {
                const chunkData = allChunks[i];
                
                // Calculate height of this item
                let itemHeight = 0;
                if (chunkData.type === 'paragraph-break') {
                    itemHeight = view.calculateParagraphBreakHeight();
                } else if (chunkData.type === 'content-chunk') {
                    itemHeight = view.calculateChunkHeight();
                }
                
                // Check if we need a new page
                if (currentPageHeight + itemHeight > view.USABLE_PAGE_HEIGHT && currentPageHeight > 0) {
                    // Close current paragraph group if needed
                    if (currentParagraphGroup !== null) {
                        html += '                    </div>\n'; // close paragraph-group
                    }
                    
                    // Close current page
                    html += '                </div>\n'; // close editor-area
                    html += '            </div>\n'; // close page-content
                    html += '        </div>\n'; // close page
                    
                    // Start new page
                    html += '        <div class="page">\n';
                    html += '            <div class="page-content">\n';
                    html += '                <div class="editor-area">\n';
                    
                    currentPageHeight = 0;
                    currentParagraphGroup = null;
                    lastGroupIndex = -1;
                }
                
                if (chunkData.type === 'paragraph-break') {
                    // Create standalone paragraph break
                    html += '                    <div class="paragraph-break-header">\n';
                    html += '                        <span class="paragraph-break-symbol">§</span>\n';
                    html += '                    </div>\n';
                    currentPageHeight += itemHeight;
                    
                } else if (chunkData.type === 'content-chunk') {
                    // Create or reuse paragraph group
                    if (chunkData.groupIndex !== lastGroupIndex) {
                        if (currentParagraphGroup !== null) {
                            html += '                    </div>\n'; // close previous paragraph-group
                        }
                        html += '                    <div class="paragraph-group">\n';
                        currentParagraphGroup = chunkData.groupIndex;
                        lastGroupIndex = chunkData.groupIndex;
                    }
                    
                    // Create the chunk
                    html += '                        <div class="stream-chunk">\n';
                    
                    for (let streamIndex = 0; streamIndex < doc.streamCount; streamIndex++) {
                        const line = chunkData.streamLines[streamIndex][chunkData.chunkIndex] || '';
                        html += `                            <div class="stream stream-${streamIndex}">${line}</div>\n`;
                    }
                    
                    html += '                        </div>\n';
                    currentPageHeight += itemHeight;
                }
            }
            
            // Close final paragraph group if needed
            if (currentParagraphGroup !== null) {
                html += '                    </div>\n'; // close final paragraph-group
            }
            
            // Close final page
            html += '                </div>\n'; // close editor-area
            html += '            </div>\n'; // close page-content
            html += '        </div>\n'; // close page
            
            html += `    </div>
</body>
</html>`;
            
            const blob = new Blob([html], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${title.replace(/[^a-z0-9]/gi, '_')}.html`;
            a.click();
            URL.revokeObjectURL(url);
        }
        
        function exportPdf() {
            const title = doc.title || 'Multi-Voice Story';
            
            // Create a new window with PDF-optimized HTML
            const pdfWindow = window.open('', '_blank');
            
            // Generate HTML specifically optimized for PDF printing
            const html = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${title}</title>
    <style>
        @page {
            size: 8.5in 11in;
            margin: 0.75in;
            @top-left { content: ""; }
            @top-center { content: ""; }
            @top-right { content: ""; }
            @bottom-left { content: ""; }
            @bottom-center { content: ""; }
            @bottom-right { content: ""; }
        }
        
        @media print {
            @page {
                margin: 0.75in;
                size: 8.5in 11in;
                @top-left { content: ""; }
                @top-center { content: ""; }
                @top-right { content: ""; }
                @bottom-left { content: ""; }
                @bottom-center { content: ""; }
                @bottom-right { content: ""; }
            }
            
            body {
                -webkit-print-color-adjust: exact;
                print-color-adjust: exact;
                margin: 0;
                padding: 0;
            }
            
            html {
                margin: 0;
                padding: 0;
            }
        }
        
        body {
            font-family: Georgia, serif;
            margin: 0;
            padding: 0;
            background: white;
            color: black;
            line-height: 1.6;
            font-size: 12pt;
        }
        
        .page {
            width: 100%;
            background: white;
            position: relative;
            padding: 0;
            height: auto;
            page-break-after: always;
            box-sizing: border-box;
            min-height: calc(11in - 1.5in);
        }
        
        .page:last-child {
            page-break-after: avoid;
        }
        
        .title-area {
            padding: 20px 20px 40px 20px;
        }
        
        .title {
            font-family: Georgia, serif;
            font-size: 24pt;
            font-weight: bold;
            text-align: center;
            color: #2c3e50;
            padding: 20px 0;
            margin-bottom: 20px;
        }
        
        .editor-area {
            min-height: 200px;
            padding: 0;
            margin: 20px 0 0 0;
        }
        
        .paragraph-group {
            position: relative;
        }
        
        .paragraph-break-header {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 40px 0 30px 0;
            padding: 15px;
        }
        
        .paragraph-break-symbol {
            font-size: 18pt;
            color: #999;
            font-family: Georgia, serif;
        }
        
        .stream-chunk {
            position: relative;
            margin-bottom: 60px;
            page-break-inside: avoid;
        }
        
        .stream {
            min-height: 24px;
            padding: 0px 0px 0px 0px;
            margin-bottom: -3px;
            font-family: Georgia, serif;
            font-size: 12pt;
            line-height: 1.5;
            background: transparent;
            white-space: nowrap;
            width: 100%;
            color: black;
            font-style: normal;
        }
        
        .stream-0, .stream-1, .stream-2, .stream-3, .stream-4 { 
            color: black; 
            font-style: normal;
        }
        
        /* Prevent page breaks inside chunks */
        .stream-chunk {
            break-inside: avoid;
        }
        
        /* Ensure paragraph breaks stay with following content */
        .paragraph-break-header {
            break-after: avoid;
        }
    </style>
</head>
<body>
`;
            
            // Use the same pagination logic but optimized for PDF
            let currentPageContent = '';
            let titlePageHeight = 0;
            let titleHeightUsed = 0;
            
            // Start first page
            let pdfHtml = html;
            pdfHtml += '    <div class="page">\n';
            
            // Add title to first page if it exists
            if (doc.title && doc.title.trim()) {
                const titleHeight = view.measureTitleHeight();
                if (titlePageHeight + titleHeight <= PAGE_CONFIG.HEIGHT) {
                    pdfHtml += '        <div class="title-area">\n';
                    pdfHtml += `            <div class="title">${title}</div>\n`;
                    pdfHtml += '        </div>\n';
                    titlePageHeight += titleHeight;
                    titleHeightUsed = titleHeight;
                }
            }
            
            // Add editor area
            pdfHtml += '        <div class="editor-area">\n';
            
            // Build list of all chunks with their metadata (same as HTML export)
            const allChunks = [];
            
            for (let groupIndex = 0; groupIndex < doc.streamGroups.length; groupIndex++) {
                const group = doc.streamGroups[groupIndex];
                
                // Add paragraph break as a special chunk (except for first group)
                if (groupIndex > 0) {
                    allChunks.push({
                        type: 'paragraph-break',
                        groupIndex,
                        chunkIndex: -1,
                        streamLines: null
                    });
                }
                
                const streamLines = group.map(stream => view.breakTextIntoLines(stream));
                const maxChunks = Math.max(...streamLines.map(lines => lines.length));
                
                for (let chunkIndex = 0; chunkIndex < maxChunks; chunkIndex++) {
                    allChunks.push({
                        type: 'content-chunk',
                        groupIndex,
                        chunkIndex,
                        streamLines
                    });
                }
            }
            
            // Process each chunk with pagination
            let currentParagraphGroup = null;
            let lastGroupIndex = -1;
            let currentPageHeight = titleHeightUsed;
            
            for (let i = 0; i < allChunks.length; i++) {
                const chunkData = allChunks[i];
                
                // Calculate height of this item
                let itemHeight = 0;
                if (chunkData.type === 'paragraph-break') {
                    itemHeight = view.calculateParagraphBreakHeight();
                } else if (chunkData.type === 'content-chunk') {
                    itemHeight = view.calculateChunkHeight();
                }
                
                // Check if we need a new page
                if (currentPageHeight + itemHeight > view.USABLE_PAGE_HEIGHT && currentPageHeight > 0) {
                    // Close current paragraph group if needed
                    if (currentParagraphGroup !== null) {
                        pdfHtml += '            </div>\n'; // close paragraph-group
                    }
                    
                    // Close current page
                    pdfHtml += '        </div>\n'; // close editor-area
                    pdfHtml += '    </div>\n'; // close page
                    
                    // Start new page
                    pdfHtml += '    <div class="page">\n';
                    pdfHtml += '        <div class="editor-area">\n';
                    
                    currentPageHeight = 0;
                    currentParagraphGroup = null;
                    lastGroupIndex = -1;
                }
                
                if (chunkData.type === 'paragraph-break') {
                    // Create standalone paragraph break
                    pdfHtml += '            <div class="paragraph-break-header">\n';
                    pdfHtml += '                <span class="paragraph-break-symbol">§</span>\n';
                    pdfHtml += '            </div>\n';
                    currentPageHeight += itemHeight;
                    
                } else if (chunkData.type === 'content-chunk') {
                    // Create or reuse paragraph group
                    if (chunkData.groupIndex !== lastGroupIndex) {
                        if (currentParagraphGroup !== null) {
                            pdfHtml += '            </div>\n'; // close previous paragraph-group
                        }
                        pdfHtml += '            <div class="paragraph-group">\n';
                        currentParagraphGroup = chunkData.groupIndex;
                        lastGroupIndex = chunkData.groupIndex;
                    }
                    
                    // Create the chunk
                    pdfHtml += '                <div class="stream-chunk">\n';
                    
                    for (let streamIndex = 0; streamIndex < doc.streamCount; streamIndex++) {
                        const line = chunkData.streamLines[streamIndex][chunkData.chunkIndex] || '';
                        pdfHtml += `                    <div class="stream stream-${streamIndex}">${line}</div>\n`;
                    }
                    
                    pdfHtml += '                </div>\n';
                    currentPageHeight += itemHeight;
                }
            }
            
            // Close final paragraph group if needed
            if (currentParagraphGroup !== null) {
                pdfHtml += '            </div>\n'; // close final paragraph-group
            }
            
            // Close final page
            pdfHtml += '        </div>\n'; // close editor-area
            pdfHtml += '    </div>\n'; // close page
            
            pdfHtml += '</body>\n</html>';
            
            // Write the HTML to the new window
            pdfWindow.document.write(pdfHtml);
            pdfWindow.document.close();
            
            // Wait for content to load, then trigger print dialog
            setTimeout(() => {
                pdfWindow.focus();
                
                // Show instructions for clean printing  
                // const instructions = 'IMPORTANT - To Remove Headers/Footers:\\n\\n' +
                //     '1. In the print dialog that opens, click "More settings"\\n' +
                //     '2. UNCHECK "Headers and footers" (this removes date, title, page numbers, and "about:blank")\\n' +
                //     '3. Choose "Save as PDF"\\n\\n' +
                //     'If you dont see "More settings", look for "Options" or "Advanced".\\n\\n' +
                //     'Click OK to open the print dialog.';
                // alert(instructions);
                
                pdfWindow.print();
                
                // Optional: Close the window after printing (uncomment if desired)
                // setTimeout(() => {
                //     pdfWindow.close();
                // }, 1000);
            }, 500);
        }
        
        function exportLatex() {
            const title = doc.title || 'Multi-Voice Story';
            
            let latex = `\\documentclass[11pt]{article}
\\usepackage[margin=1in]{geometry}
\\usepackage{paracol}
\\usepackage{xcolor}

\\title{${title}}
\\author{Your Name}
\\date{}

% Define colors for each voice
\\definecolor{voice1color}{RGB}{139,69,19}
\\definecolor{voice2color}{RGB}{44,62,80}
\\definecolor{voice3color}{RGB}{70,130,180}
\\definecolor{voice4color}{RGB}{39,174,96}
\\definecolor{voice5color}{RGB}{231,76,60}

% Commands for each voice
\\newcommand{\\voiceone}[1]{\\textcolor{voice1color}{\\textit{#1}}}
\\newcommand{\\voicetwo}[1]{\\textcolor{voice2color}{#1}}
\\newcommand{\\voicethree}[1]{\\textcolor{voice3color}{\\textit{#1}}}
\\newcommand{\\voicefour}[1]{\\textcolor{voice4color}{\\textit{#1}}}
\\newcommand{\\voicefive}[1]{\\textcolor{voice5color}{\\textit{#1}}}

\\begin{document}
\\maketitle

\\begin{paracol}{${doc.streamCount}}

`;
            
            for (let groupIndex = 0; groupIndex < doc.streamGroups.length; groupIndex++) {
                const group = doc.streamGroups[groupIndex];
                
                if (groupIndex > 0) {
                    latex += '\n\\switchcolumn*\n\\vspace{20pt}\n\\switchcolumn*\n\n';
                }
                
                const streamLines = group.map(stream => view.breakTextIntoLines(stream));
                const maxChunks = Math.max(...streamLines.map(lines => lines.length));
                
                for (let chunkIndex = 0; chunkIndex < maxChunks; chunkIndex++) {
                    for (let streamIndex = 0; streamIndex < doc.streamCount; streamIndex++) {
                        const line = streamLines[streamIndex][chunkIndex] || '';
                        const commands = ['\\voiceone', '\\voicetwo', '\\voicethree', '\\voicefour', '\\voicefive'];
                        const command = commands[streamIndex] || '\\voicetwo';
                        
                        if (line) {  // Export all content, including whitespace-only lines
                            latex += `${command}{${line.replace(/&/g, '\\&').replace(/#/g, '\\#')}}\n`;
                        }
                        
                        if (streamIndex < doc.streamCount - 1) {
                            latex += '\\switchcolumn\n';
                        }
                    }
                    
                    if (chunkIndex < maxChunks - 1) {
                        latex += '\n\\switchcolumn*\n\n';
                    }
                }
            }
            
            latex += `

\\end{paracol}
\\end{document}`;
            
            const blob = new Blob([latex], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${title.replace(/[^a-z0-9]/gi, '_')}.tex`;
            a.click();
            URL.revokeObjectURL(url);
        }
        
        function clearAll() {
            if (confirm('Clear all content? This cannot be undone.')) {
                doc.streamGroups = [new Array(doc.streamCount).fill('')];
                doc.title = '';
                doc.activeStream = 0;
                doc.activeCursor = 0;
                doc.activeGroup = 0;
                
                // Clear title input
                document.getElementById('titleInput').textContent = '';
                
                // Clear auto-save as well
                doc.clearAutoSave();
                
                doc.notifyChange();
            }
        }
        
        // Add global keyboard shortcuts
        document.addEventListener('keydown', function(event) {
            // Check for Cmd/Ctrl key combinations
            const isCtrlOrCmd = event.ctrlKey || event.metaKey;
            
            if (isCtrlOrCmd && event.key === 'z' && !event.shiftKey) {
                // Cmd+Z / Ctrl+Z - Undo
                event.preventDefault();
                doc.undo();
            } else if (isCtrlOrCmd && (event.key === 'y' || (event.key === 'z' && event.shiftKey))) {
                // Cmd+Y / Ctrl+Y or Cmd+Shift+Z / Ctrl+Shift+Z - Redo
                event.preventDefault();
                doc.redo();
            } else if (event.ctrlKey && event.shiftKey && event.key === 'P') {
                // Ctrl+Shift+P - Insert Paragraph Break
                event.preventDefault();
                insertParagraphBreak();
            }
        });
        
        // Apply page configuration and initialize
        applyPageConfiguration();
        document.getElementById('streamCount').textContent = doc.streamCount;
        view.render();
    </script>
</body>
</html>

