<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multi-Stream Text Editor</title>
    <style>
        /* EXACT SAME STYLES AS YOUR ORIGINAL */
        body {
            font-family: Georgia, serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        
        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 0 20px;
        }
        
        .toolbar {
            background: #f5f5f5;
            padding: 20px 30px;
            font-size: 12px;
            color: #666;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .stream-indicator {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .stream-count {
            padding: 2px 6px;
            background: #3498db;
            color: white;
            border-radius: 3px;
            font-size: 11px;
        }
        
        .controls {
            display: flex;
            gap: 8px;
        }
        
        .btn {
            padding: 10px;
            background: transparent;
            border: none;
            border-radius: 6px;
            font-size: 16px;
            cursor: pointer;
            color: #6c757d;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 36px;
            height: 36px;
        }
        
        .btn:hover {
            background: #f8f9fa;
            color: #495057;
            transform: translateY(-1px);
        }
        
        .btn:active {
            transform: translateY(0);
            background: #e9ecef;
        }
        
        /* Custom tooltip styles */
        .btn {
            position: relative;
        }
        
        .btn::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: -35px;
            left: 50%;
            transform: translateX(-50%);
            background: #343a40;
            color: white;
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 11px;
            font-weight: 500;
            white-space: nowrap;
            opacity: 0;
            visibility: hidden;
            transition: all 0.2s ease;
            pointer-events: none;
            z-index: 1000;
        }
        
        .btn:hover::after {
            opacity: 1;
            visibility: visible;
        }
        
        .content-area {
            background: transparent;
            margin-bottom: 20px;
        }
        
        .pages-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 30px;
            padding: 20px 0;
        }
        
        .page {
            max-width: 900px;
            width: 100%;
            background: white;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            position: relative;
            padding: 0;
            overflow: hidden;
            height: 1400px;
        }
        
        .page-content {
            height: 100%;
            overflow: hidden;
            position: relative;
            box-sizing: border-box;
            padding: 60px 80px 10px 80px;
        }
        
        .title-area {
            padding: 20px 20px 40px 20px;
        }
        
        .title-input {
            width: 100%;
            border: none;
            outline: none;
            font-family: Georgia, serif;
            font-size: 28px;
            font-weight: bold;
            text-align: center;
            background: transparent;
            color: #2c3e50;
            padding: 20px 0;
            resize: none;
            overflow: hidden;
        }
        
        .title-input:focus {
            background: rgba(52, 152, 219, 0.02);
        }
        
        .title-input:empty::before {
            content: attr(data-placeholder);
            color: #bdc3c7;
            font-style: italic;
            font-weight: normal;
        }
        
        .editor-area {
            min-height: 200px;
            padding: 0;
            margin: 20px 0 0 0;
        }
        
        .paragraph-group {
            position: relative;
        }
        
        .paragraph-break-header {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 60px 0 40px 0;
            padding: 20px;
            cursor: pointer;
        }
        
        .paragraph-break-symbol {
            font-size: 24px;
            color: #adb5bd;
            font-family: Georgia, serif;
            user-select: none;
            transition: all 0.2s ease;
            position: relative;
        }
        
        .paragraph-delete-indicator {
            position: absolute;
            top: -8px;
            right: -12px;
            background: #dc3545;
            color: white;
            border-radius: 50%;
            width: 16px;
            height: 16px;
            font-size: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transform: scale(0.8);
            transition: all 0.2s ease;
            font-family: monospace;
            font-weight: bold;
        }
        
        .paragraph-break-header:hover .paragraph-break-symbol {
            color: #868e96;
        }
        
        .paragraph-break-header:hover .paragraph-delete-indicator {
            opacity: 1;
            transform: scale(1);
        }
        
        .stream-chunk {
            position: relative;
            margin-bottom: 75px;
        }
        
        .stream-chunk::before {
            content: attr(data-chunk-number);
            position: absolute;
            right: 10px;
            top: 5px;
            font-size: 10px;
            color: #ccc;
            background: white;
            padding: 2px 4px;
            border-radius: 2px;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 10;
        }
        
        .stream-chunk:hover::before {
            opacity: 1;
        }
        
        /* CHANGED: streams are now display-only, not editable */
        .stream {
            min-height: 30px;
            padding: 0px 0px 0px 10px;
            margin-bottom: -4px;
            border: none;
            outline: none;
            font-family: Georgia, serif;
            font-size: 16px; 
            line-height: 1.6;
            resize: none;
            background: transparent;
            overflow: hidden;
            white-space: nowrap;
            width: 100%;
            cursor: text;
            user-select: none;
        }
        
        .stream.editing {
            background: rgba(52, 152, 219, 0.02);
        }
        
        .stream:empty::before {
            content: attr(data-placeholder);
            color: #999;
            font-style: italic;
        }
        
        .stream-0, .stream-1, .stream-2, .stream-3, .stream-4 { 
            color: black; 
            font-style: normal;
            border-left: 3px solid rgba(233, 233, 233, 0.3);
            margin-left: -10px;
        }
        
        /* NEW: Hidden editor overlay */
        .hidden-editor {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1000;
        }
        
        .hidden-editor textarea {
            position: absolute;
            opacity: 0.1;
            pointer-events: auto;
            font-family: Georgia, serif;
            font-size: 16px;
            line-height: 1.6;
            border: 1px solid rgba(0, 123, 255, 0.3);
            outline: none;
            resize: none;
            padding: 0px 0px 0px 10px;
            margin: 0;
            overflow: hidden;
            background: rgba(255, 255, 255, 0.9);
            color: transparent;
            caret-color: black;
            z-index: 1001;
        }
        
        .footer {
            padding: 10px 20px;
            background: #f5f5f5;
            font-size: 11px;
            color: #999;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .footer-counters {
            font-size: 11px;
            color: #999;
        }
        
        /* Hidden measuring element */
        .text-measure {
            position: absolute;
            left: -9999px;
            top: -9999px;
            font-family: Georgia, serif;
            font-size: 16px;
            line-height: 1.6;
            white-space: nowrap;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="toolbar">
            <div></div>
            <div class="controls">
                <button class="btn" id="undoBtn" onclick="undoAction()" data-tooltip="Undo (Cmd+Z)">
                    <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
                        <path d="M3 7v6M3 7l4-4M3 7l4 4M7 7h8" stroke="#74a9d8" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                </button>
                <button class="btn" id="redoBtn" onclick="redoAction()" data-tooltip="Redo (Cmd+Y)">
                    <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
                        <path d="M13 7v6M13 7l-4-4M13 7l-4 4M9 7H1" stroke="#74a9d8" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                </button>
                <button class="btn" onclick="changeStreamCount()" data-tooltip="Change Voices">
                    <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
                        <path d="M2 4h12M2 8h12M2 12h12" stroke="#74a9d8" stroke-width="1.5" stroke-linecap="round"/>
                    </svg>
                </button>
                <button class="btn" onclick="insertParagraphBreak()" data-tooltip="Paragraph Break (Ctrl+Shift+P)">
                    <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
                        <path d="M12 2v12M13.5 2H5a2 2 0 0 0-2 2v0a2 2 0 0 0 2 2h3M8 2v12" stroke="#74a9d8" stroke-width="1.5" stroke-linecap="round"/>
                    </svg>
                </button>
                <button class="btn" onclick="saveFile()" data-tooltip="Save Document">
                    <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
                        <path d="M13 15H3a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1h7l4 4v9a1 1 0 0 1-1 1z" stroke="#74a9d8" stroke-width="1.5"/>
                        <path d="M11 1v4H5V1M11 15v-6H5v6" stroke="#74a9d8" stroke-width="1.5"/>
                    </svg>
                </button>
                <button class="btn" onclick="loadFile()" data-tooltip="Load Document">
                    <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
                        <path d="M8 1v10M5 8l3 3 3-3M2 14h12" stroke="#74a9d8" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                </button>
                <button class="btn" onclick="exportHtml()" data-tooltip="Export HTML">
                    <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
                        <circle cx="8" cy="8" r="7" stroke="#74a9d8" stroke-width="1.5"/>
                        <path d="M1 8h14" stroke="#74a9d8" stroke-width="1"/>
                        <path d="M2 5.5Q8 4.5 14 5.5M2 10.5Q8 11.5 14 10.5" stroke="#74a9d8" stroke-width="1"/>
                        <path d="M8 1c1.8 0 3.2 3 3.2 7s-1.4 7-3.2 7-3.2-3-3.2-7 1.4-7 3.2-7z" stroke="#74a9d8" stroke-width="1"/>
                    </svg>
                </button>
                <button class="btn" onclick="exportPdf()" data-tooltip="Export PDF">
                    <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
                        <path d="M13 15H3a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1h7l4 4v9a1 1 0 0 1-1 1z" stroke="#74a9d8" stroke-width="1.5"/>
                        <path d="M11 1v4H5V1" stroke="#74a9d8" stroke-width="1.5"/>
                        <path d="M3 8h10M3 11h7" stroke="#74a9d8" stroke-width="1.5"/>
                    </svg>
                </button>
                <button class="btn" onclick="clearAll()" data-tooltip="Clear All">
                    <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
                        <path d="M3 5v9a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1V5M1 5h14M5 5V3a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v2" stroke="#74a9d8" stroke-width="1.5"/>
                        <path d="M6 8v4M10 8v4" stroke="#74a9d8" stroke-width="1.5" stroke-linecap="round"/>
                    </svg>
                </button>
            </div>
        </div>
        
        <div class="content-area">
            <div class="pages-container" id="pagesContainer">
                <!-- Pages will be added here -->
            </div>
        </div>
        
        <div class="footer">
            <div>Click to edit • Tab for spaces • Shift+Tab to switch voices • Escape to stop editing</div>
            <div class="footer-counters">
                <span id="streamCount">3</span> voices • <span id="chunkCount">1</span> chunks
                <span id="autoSaveIndicator" style="opacity: 0; margin-left: 15px; color: #999;"></span>
            </div>
        </div>
        
        <!-- Hidden editor overlay -->
        <div class="hidden-editor" id="hiddenEditor"></div>
        
        <!-- Hidden measuring element -->
        <div class="text-measure" id="textMeasure"></div>
    </div>

    <script>
        // ===== PAGE CONFIGURATION - SAME AS ORIGINAL =====
        const PAGE_CONFIG = {
            HEIGHT: 1400,
            MARGIN_TOP: 60,
            MARGIN_RIGHT: 80,
            MARGIN_BOTTOM: 10,
            MARGIN_LEFT: 80,
            
            get USABLE_HEIGHT() {
                return this.HEIGHT - this.MARGIN_TOP - this.MARGIN_BOTTOM;
            },
            get CSS_PADDING() {
                return `${this.MARGIN_TOP}px ${this.MARGIN_RIGHT}px ${this.MARGIN_BOTTOM}px ${this.MARGIN_LEFT}px`;
            }
        };
        
        // ===== DOCUMENT MODEL - Single source of truth =====
        class MultiStreamDocument {
            constructor(streamCount = 3) {
                this.streamGroups = [new Array(streamCount).fill('')];
                this.streamCount = streamCount;
                this.title = '';
                this.listeners = [];
                
                // History for undo/redo
                this.history = [];
                this.historyIndex = -1;
                this.maxHistory = 50;
                
                this.saveState();
            }
            
            getStreamText(groupIndex, streamIndex) {
                return this.streamGroups[groupIndex][streamIndex];
            }
            
            updateStreamText(groupIndex, streamIndex, newText) {
                const oldText = this.streamGroups[groupIndex][streamIndex];
                if (oldText !== newText) {
                    this.saveState();
                    this.streamGroups[groupIndex][streamIndex] = newText;
                    this.notifyChange();
                }
            }
            
            insertParagraphBreak(groupIndex, streamIndex, position) {
                this.saveState();
                
                const currentGroup = this.streamGroups[groupIndex];
                const newGroup = new Array(this.streamCount).fill('');
                
                // Split the specific stream at position
                const text = currentGroup[streamIndex];
                currentGroup[streamIndex] = text.substring(0, position);
                newGroup[streamIndex] = text.substring(position);
                
                // For other streams, keep them in current group (don't split)
                for (let i = 0; i < this.streamCount; i++) {
                    if (i !== streamIndex) {
                        newGroup[i] = '';
                    }
                }
                
                this.streamGroups.splice(groupIndex + 1, 0, newGroup);
                this.notifyChange();
            }
            
            removeParagraphBreak(groupIndex) {
                if (groupIndex < this.streamGroups.length - 1) {
                    this.saveState();
                    
                    const currentGroup = this.streamGroups[groupIndex];
                    const nextGroup = this.streamGroups[groupIndex + 1];
                    
                    // Merge streams
                    for (let i = 0; i < this.streamCount; i++) {
                        currentGroup[i] = currentGroup[i] + nextGroup[i];
                    }
                    
                    this.streamGroups.splice(groupIndex + 1, 1);
                    this.notifyChange();
                }
            }
            
            setTitle(title) {
                if (this.title !== title) {
                    this.saveState();
                    this.title = title;
                }
            }
            
            onChange(callback) {
                this.listeners.push(callback);
            }
            
            notifyChange() {
                this.listeners.forEach(callback => callback());
            }
            
            saveState() {
                const state = {
                    streamGroups: JSON.parse(JSON.stringify(this.streamGroups)),
                    streamCount: this.streamCount,
                    title: this.title
                };
                
                if (this.historyIndex < this.history.length - 1) {
                    this.history = this.history.slice(0, this.historyIndex + 1);
                }
                
                this.history.push(state);
                this.historyIndex = this.history.length - 1;
                
                if (this.history.length > this.maxHistory) {
                    this.history.shift();
                    this.historyIndex--;
                }
                
                this.updateUndoRedoButtons();
            }
            
            undo() {
                if (this.historyIndex > 0) {
                    this.historyIndex--;
                    this.restoreState(this.history[this.historyIndex]);
                    this.updateUndoRedoButtons();
                    return true;
                }
                return false;
            }
            
            redo() {
                if (this.historyIndex < this.history.length - 1) {
                    this.historyIndex++;
                    this.restoreState(this.history[this.historyIndex]);
                    this.updateUndoRedoButtons();
                    return true;
                }
                return false;
            }
            
            restoreState(state) {
                this.streamGroups = JSON.parse(JSON.stringify(state.streamGroups));
                this.streamCount = state.streamCount;
                this.title = state.title;
                
                // Update UI
                document.getElementById('titleInput').textContent = this.title;
                document.getElementById('streamCount').textContent = this.streamCount;
                
                this.notifyChange();
            }
            
            updateUndoRedoButtons() {
                const undoBtn = document.getElementById('undoBtn');
                const redoBtn = document.getElementById('redoBtn');
                
                if (undoBtn) {
                    undoBtn.style.opacity = this.historyIndex > 0 ? '1' : '0.5';
                }
                
                if (redoBtn) {
                    redoBtn.style.opacity = this.historyIndex < this.history.length - 1 ? '1' : '0.5';
                }
            }
        }
        
        // ===== NEW EDITOR CONTROLLER - Manages the hidden textarea =====
        class StreamEditor {
            constructor(document, view) {
                this.document = document;
                this.view = view;
                this.activeTextarea = null;
                this.activeGroupIndex = null;
                this.activeStreamIndex = null;
                this.isEditing = false;
            }
            
            startEditing(groupIndex, streamIndex, clickPosition, clickedElement) {
                // Stop any existing edit
                this.stopEditing();
                
                // Get the full text for this stream
                const fullText = this.document.getStreamText(groupIndex, streamIndex);
                
                // Create a textarea
                const textarea = document.createElement('textarea');
                textarea.value = fullText;
                textarea.id = `stream-editor-${Date.now()}`;
                
                // Position the textarea over the clicked element
                if (clickedElement) {
                    const rect = clickedElement.getBoundingClientRect();
                    textarea.style.left = rect.left + 'px';
                    textarea.style.top = rect.top + 'px';
                    textarea.style.width = rect.width + 'px';
                    textarea.style.height = rect.height + 'px';
                } else {
                    textarea.style.width = '1px';
                    textarea.style.height = '1px';
                }
                
                // Add to hidden editor container
                const container = document.getElementById('hiddenEditor');
                container.appendChild(textarea);
                
                // Focus and set cursor position
                textarea.focus();
                textarea.setSelectionRange(clickPosition, clickPosition);
                
                // Track state
                this.activeTextarea = textarea;
                this.activeGroupIndex = groupIndex;
                this.activeStreamIndex = streamIndex;
                this.isEditing = true;
                
                // Mark the visual chunks as being edited
                this.highlightEditingChunks();
                
                // Handle input
                textarea.addEventListener('input', () => {
                    this.document.updateStreamText(groupIndex, streamIndex, textarea.value);
                });
                
                // Handle special keys
                textarea.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') {
                        this.stopEditing();
                    } else if (e.key === 'Tab' && e.shiftKey) {
                        e.preventDefault();
                        // Switch to next voice
                        const nextStream = (streamIndex + 1) % this.document.streamCount;
                        const cursorPos = textarea.selectionStart;
                        this.stopEditing();
                        this.startEditing(groupIndex, nextStream, Math.min(cursorPos, this.document.getStreamText(groupIndex, nextStream).length));
                    } else if (e.key === 'Tab') {
                        e.preventDefault();
                        // Insert spaces
                        const start = textarea.selectionStart;
                        const end = textarea.selectionEnd;
                        const spaces = '            ';
                        textarea.value = textarea.value.substring(0, start) + spaces + textarea.value.substring(end);
                        textarea.setSelectionRange(start + spaces.length, start + spaces.length);
                        textarea.dispatchEvent(new Event('input'));
                    } else if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key === 'P') {
                        e.preventDefault();
                        // Insert paragraph break at cursor
                        const position = textarea.selectionStart;
                        this.document.insertParagraphBreak(groupIndex, streamIndex, position);
                        this.stopEditing();
                    }
                });
            }
            
            stopEditing() {
                if (!this.isEditing) return;
                
                // Remove textarea
                if (this.activeTextarea) {
                    this.activeTextarea.remove();
                    this.activeTextarea = null;
                }
                
                // Clear highlights
                document.querySelectorAll('.stream.editing').forEach(el => {
                    el.classList.remove('editing');
                });
                
                this.isEditing = false;
                this.activeGroupIndex = null;
                this.activeStreamIndex = null;
            }
            
            highlightEditingChunks() {
                // Highlight all chunks for this stream in this group
                document.querySelectorAll(
                    `[data-stream-index="${this.activeStreamIndex}"][data-group-index="${this.activeGroupIndex}"]`
                ).forEach(el => {
                    el.classList.add('editing');
                });
            }
        }
        
        // ===== VIEW - Renders display-only chunks =====
        class MultiStreamView {
            constructor(container, docModel) {
                this.container = container;
                this.document = docModel;
                this.editor = new StreamEditor(docModel, this);
                this.maxLineWidth = 700;
                this.isUpdating = false;
                
                // Constants
                this.PAGE_HEIGHT = PAGE_CONFIG.HEIGHT;
                this.USABLE_PAGE_HEIGHT = PAGE_CONFIG.USABLE_HEIGHT;
                this.TITLE_HEIGHT = 120;
                this.PARAGRAPH_BREAK_HEIGHT = 120;
                this.STREAM_LINE_HEIGHT = 25.6;
                this.CHUNK_MARGIN = 75;
                
                this.calculateMaxWidth();
                this.document.onChange(() => this.render());
                
                window.addEventListener('resize', () => {
                    this.calculateMaxWidth();
                    this.render();
                });
                
                // Global click handler to stop editing
                window.document.addEventListener('click', (e) => {
                    if (!e.target.closest('.stream') && !e.target.closest('textarea')) {
                        this.editor.stopEditing();
                    }
                });
            }
            
            calculateMaxWidth() {
                const container = document.querySelector('.container');
                if (container) {
                    const containerWidth = container.offsetWidth - 40;
                    const pageWidth = Math.min(containerWidth, 900);
                    this.maxLineWidth = pageWidth - (PAGE_CONFIG.MARGIN_LEFT + PAGE_CONFIG.MARGIN_RIGHT);
                }
            }
            
            measureTextWidth(text) {
                const measure = document.getElementById('textMeasure');
                measure.textContent = text;
                return measure.offsetWidth;
            }
            
            breakTextIntoLines(text) {
                if (!text) return [''];
                
                const lines = [];
                let currentLine = '';
                let i = 0;
                
                while (i < text.length) {
                    const char = text[i];
                    const testLine = currentLine + char;
                    const width = this.measureTextWidth(testLine);
                    
                    if (width <= this.maxLineWidth) {
                        currentLine = testLine;
                        i++;
                    } else {
                        if (currentLine === '') {
                            currentLine = char;
                            i++;
                        } else {
                            // Find break point
                            let breakPoint = currentLine.length;
                            
                            for (let j = currentLine.length - 1; j >= Math.max(0, currentLine.length - 20); j--) {
                                const c = currentLine[j];
                                if (c === ' ' || c === '\t' || c === '-' || c === '.' || c === ',') {
                                    breakPoint = j + 1;
                                    break;
                                }
                            }
                            
                            if (breakPoint < currentLine.length) {
                                lines.push(currentLine.substring(0, breakPoint));
                                currentLine = currentLine.substring(breakPoint);
                            } else {
                                lines.push(currentLine);
                                currentLine = '';
                            }
                        }
                    }
                }
                
                if (currentLine || lines.length === 0) {
                    lines.push(currentLine);
                }
                
                return lines;
            }
            
            render() {
                if (this.isUpdating) return;
                this.isUpdating = true;
                
                const pagesContainer = document.getElementById('pagesContainer');
                pagesContainer.innerHTML = '';
                
                // Build pages
                let currentPage = this.createNewPage();
                let currentPageHeight = 0;
                let totalChunks = 0;
                
                // Add title
                const titleHeight = this.TITLE_HEIGHT;
                if (currentPageHeight + titleHeight <= this.PAGE_HEIGHT) {
                    const titleArea = this.createTitleArea();
                    currentPage.querySelector('.page-content').appendChild(titleArea);
                    currentPageHeight += titleHeight;
                }
                
                let currentEditorArea = this.createEditorArea();
                currentPage.querySelector('.page-content').appendChild(currentEditorArea);
                
                // Process all chunks
                const allChunks = [];
                
                for (let groupIndex = 0; groupIndex < this.document.streamGroups.length; groupIndex++) {
                    const group = this.document.streamGroups[groupIndex];
                    
                    if (groupIndex > 0) {
                        allChunks.push({
                            type: 'paragraph-break',
                            groupIndex,
                            chunkIndex: -1,
                            streamLines: null
                        });
                    }
                    
                    const streamLines = group.map(stream => this.breakTextIntoLines(stream));
                    const maxChunks = Math.max(...streamLines.map(lines => lines.length));
                    
                    for (let chunkIndex = 0; chunkIndex < maxChunks; chunkIndex++) {
                        allChunks.push({
                            type: 'content-chunk',
                            groupIndex,
                            chunkIndex,
                            streamLines
                        });
                    }
                }
                
                // Render chunks with pagination
                let currentParagraphGroup = null;
                let lastGroupIndex = -1;
                currentPageHeight = titleHeight;
                
                for (let i = 0; i < allChunks.length; i++) {
                    const chunkData = allChunks[i];
                    
                    let itemHeight = 0;
                    if (chunkData.type === 'paragraph-break') {
                        itemHeight = this.PARAGRAPH_BREAK_HEIGHT;
                    } else if (chunkData.type === 'content-chunk') {
                        itemHeight = this.calculateChunkHeight();
                    }
                    
                    if (currentPageHeight + itemHeight > this.USABLE_PAGE_HEIGHT && currentPageHeight > 0) {
                        pagesContainer.appendChild(currentPage);
                        currentPage = this.createNewPage();
                        currentPageHeight = 0;
                        currentEditorArea = this.createEditorArea();
                        currentPage.querySelector('.page-content').appendChild(currentEditorArea);
                        currentParagraphGroup = null;
                        lastGroupIndex = -1;
                    }
                    
                    if (chunkData.type === 'paragraph-break') {
                        const paragraphBreak = this.createStandaloneParagraphBreak(chunkData.groupIndex);
                        currentEditorArea.appendChild(paragraphBreak);
                        currentPageHeight += itemHeight;
                    } else if (chunkData.type === 'content-chunk') {
                        if (chunkData.groupIndex !== lastGroupIndex) {
                            currentParagraphGroup = this.createParagraphGroupWithoutBreak(chunkData.groupIndex);
                            currentEditorArea.appendChild(currentParagraphGroup);
                            lastGroupIndex = chunkData.groupIndex;
                        }
                        
                        const chunk = this.createChunk(totalChunks + 1, chunkData.groupIndex, chunkData.chunkIndex);
                        
                        for (let streamIndex = 0; streamIndex < this.document.streamCount; streamIndex++) {
                            const stream = this.createStream(
                                streamIndex,
                                chunkData.chunkIndex,
                                chunkData.streamLines[streamIndex][chunkData.chunkIndex] || '',
                                chunkData.groupIndex,
                                chunkData.streamLines[streamIndex]
                            );
                            chunk.appendChild(stream);
                        }
                        
                        currentParagraphGroup.appendChild(chunk);
                        currentPageHeight += itemHeight;
                        totalChunks++;
                    }
                }
                
                pagesContainer.appendChild(currentPage);
                
                document.getElementById('chunkCount').textContent = totalChunks;
                this.isUpdating = false;
            }
            
            createNewPage() {
                const page = document.createElement('div');
                page.className = 'page';
                
                const pageContent = document.createElement('div');
                pageContent.className = 'page-content';
                
                page.appendChild(pageContent);
                return page;
            }
            
            createTitleArea() {
                const titleArea = document.createElement('div');
                titleArea.className = 'title-area';
                
                const titleInput = document.createElement('div');
                titleInput.className = 'title-input';
                titleInput.contentEditable = true;
                titleInput.dataset.placeholder = 'Enter your story title...';
                titleInput.id = 'titleInput';
                titleInput.textContent = this.document.title || '';
                
                titleInput.addEventListener('input', (e) => {
                    this.document.setTitle(e.target.textContent);
                });
                
                titleArea.appendChild(titleInput);
                return titleArea;
            }
            
            createEditorArea() {
                const editorArea = document.createElement('div');
                editorArea.className = 'editor-area';
                return editorArea;
            }
            
            createParagraphGroupWithoutBreak(groupIndex) {
                const paragraphGroup = document.createElement('div');
                paragraphGroup.className = 'paragraph-group';
                paragraphGroup.dataset.groupIndex = groupIndex;
                return paragraphGroup;
            }
            
            createStandaloneParagraphBreak(groupIndex) {
                const breakHeader = document.createElement('div');
                breakHeader.className = 'paragraph-break-header';
                breakHeader.title = 'Click to remove paragraph break';
                breakHeader.onclick = () => this.document.removeParagraphBreak(groupIndex - 1);
                
                const symbol = document.createElement('span');
                symbol.className = 'paragraph-break-symbol';
                symbol.innerHTML = '§';
                
                const deleteIndicator = document.createElement('span');
                deleteIndicator.className = 'paragraph-delete-indicator';
                deleteIndicator.innerHTML = '×';
                
                symbol.appendChild(deleteIndicator);
                breakHeader.appendChild(symbol);
                
                return breakHeader;
            }
            
            createChunk(number, groupIndex, localChunkIndex) {
                const chunk = document.createElement('div');
                chunk.className = 'stream-chunk';
                chunk.dataset.chunkNumber = number;
                chunk.dataset.groupIndex = groupIndex;
                chunk.dataset.localChunkIndex = localChunkIndex;
                return chunk;
            }
            
            createStream(streamIndex, chunkIndex, displayText, groupIndex, allLines) {
                const stream = document.createElement('div');
                stream.className = `stream stream-${streamIndex}`;
                stream.dataset.streamIndex = streamIndex;
                stream.dataset.chunkIndex = chunkIndex;
                stream.dataset.groupIndex = groupIndex;
                stream.textContent = displayText;
                
                if (streamIndex === 0 && chunkIndex === 0 && groupIndex === 0 && !displayText) {
                    stream.dataset.placeholder = 'Start writing...';
                }
                
                // Click to edit
                stream.addEventListener('click', (e) => {
                    e.stopPropagation();
                    
                    // Calculate where in the full text the user clicked
                    let clickPosition = 0;
                    
                    // Add up all previous chunks
                    for (let i = 0; i < chunkIndex; i++) {
                        clickPosition += (allLines[i] || '').length;
                    }
                    
                    // Try to estimate position within current chunk (simplified)
                    // In a real implementation, you'd calculate based on the click coordinates
                    clickPosition += displayText.length / 2;
                    
                    // Start editing
                    this.editor.startEditing(groupIndex, streamIndex, clickPosition, stream);
                });
                
                return stream;
            }
            
            calculateChunkHeight() {
                const streamHeight = this.document.streamCount * this.STREAM_LINE_HEIGHT;
                return streamHeight + this.CHUNK_MARGIN;
            }
        }
        
        // Initialize
        const doc = new MultiStreamDocument(3);
        const view = new MultiStreamView(document.getElementById('pagesContainer'), doc);
        
        // Make available globally
        window.doc = doc;
        window.view = view;
        
        // Global functions
        function undoAction() {
            view.editor.stopEditing();
            doc.undo();
        }
        
        function redoAction() {
            view.editor.stopEditing();
            doc.redo();
        }
        
        function insertParagraphBreak() {
            if (view.editor.isEditing) {
                const position = view.editor.activeTextarea.selectionStart;
                doc.insertParagraphBreak(
                    view.editor.activeGroupIndex,
                    view.editor.activeStreamIndex,
                    position
                );
                view.editor.stopEditing();
            } else {
                alert('Click in a text area first to place the paragraph break');
            }
        }
        
        function changeStreamCount() {
            view.editor.stopEditing();
            const newCount = prompt('Number of voices (2-5):', doc.streamCount);
            if (newCount && newCount >= 2 && newCount <= 5) {
                doc.streamCount = parseInt(newCount);
                
                // Resize all groups
                doc.streamGroups = doc.streamGroups.map(group => {
                    const newGroup = new Array(doc.streamCount).fill('');
                    for (let i = 0; i < Math.min(group.length, doc.streamCount); i++) {
                        newGroup[i] = group[i];
                    }
                    return newGroup;
                });
                
                document.getElementById('streamCount').textContent = doc.streamCount;
                doc.notifyChange();
            }
        }
        
        function saveFile() {
            view.editor.stopEditing();
            const content = generateSaveContent();
            const blob = new Blob([content], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${(doc.title || 'untitled').replace(/[^a-z0-9]/gi, '_')}.txt`;
            a.click();
            URL.revokeObjectURL(url);
        }
        
        function generateSaveContent() {
            const now = new Date().toISOString().split('T')[0];
            const title = doc.title || 'Untitled Story';
            
            let content = `---
streams: ${doc.streamCount}
title: "${title}"
created: "${now}"
version: "1.0"
---

`;
            
            for (let groupIndex = 0; groupIndex < doc.streamGroups.length; groupIndex++) {
                const group = doc.streamGroups[groupIndex];
                content += `=== Paragraph ${groupIndex + 1} ===\n`;
                
                for (let streamIndex = 0; streamIndex < doc.streamCount; streamIndex++) {
                    const streamText = group[streamIndex] || '';
                    if (streamText) {
                        content += `Stream ${streamIndex + 1}: ${streamText}\n`;
                    }
                }
                content += '\n';
            }
            
            return content;
        }
        
        function loadFile() {
            view.editor.stopEditing();
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.txt';
            
            input.onchange = function(e) {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = function(e) {
                    parseAndLoadFile(e.target.result);
                };
                reader.readAsText(file);
            };
            
            input.click();
        }
        
        function parseAndLoadFile(content) {
            const lines = content.split('\n');
            let metadata = {};
            let inMetadata = false;
            let paragraphs = [];
            let currentParagraph = null;
            
            for (const line of lines) {
                const trimmed = line.trim();
                
                if (trimmed === '---') {
                    inMetadata = !inMetadata;
                    continue;
                }
                
                if (inMetadata) {
                    const [key, ...valueParts] = trimmed.split(':');
                    if (key && valueParts.length > 0) {
                        const value = valueParts.join(':').trim().replace(/"/g, '');
                        metadata[key.trim()] = value;
                    }
                } else if (trimmed.startsWith('=== Paragraph')) {
                    if (currentParagraph) {
                        paragraphs.push(currentParagraph);
                    }
                    currentParagraph = {};
                } else if (trimmed.startsWith('Stream ')) {
                    const match = line.match(/^Stream (\d+): (.*)$/);
                    if (match && currentParagraph !== null) {
                        const streamIndex = parseInt(match[1]) - 1;
                        currentParagraph[streamIndex] = match[2];
                    }
                }
            }
            
            if (currentParagraph) {
                paragraphs.push(currentParagraph);
            }
            
            // Load into document
            const streamCount = parseInt(metadata.streams) || 3;
            doc.streamCount = streamCount;
            doc.title = metadata.title || '';
            
            doc.streamGroups = paragraphs.map(p => {
                const group = new Array(streamCount).fill('');
                for (let i = 0; i < streamCount; i++) {
                    group[i] = p[i] || '';
                }
                return group;
            });
            
            if (doc.streamGroups.length === 0) {
                doc.streamGroups = [new Array(streamCount).fill('')];
            }
            
            document.getElementById('streamCount').textContent = streamCount;
            doc.notifyChange();
        }
        
        function exportHtml() {
            view.editor.stopEditing();
            alert('HTML export would go here - implementation same as original');
        }
        
        function exportPdf() {
            view.editor.stopEditing();
            alert('PDF export would go here - implementation same as original');
        }
        
        function clearAll() {
            if (confirm('Clear all content? This cannot be undone.')) {
                view.editor.stopEditing();
                doc.streamGroups = [new Array(doc.streamCount).fill('')];
                doc.title = '';
                doc.notifyChange();
            }
        }
        
        // Keyboard shortcuts
        document.addEventListener('keydown', function(event) {
            const isCtrlOrCmd = event.ctrlKey || event.metaKey;
            
            if (isCtrlOrCmd && event.key === 'z' && !event.shiftKey) {
                event.preventDefault();
                undoAction();
            } else if (isCtrlOrCmd && (event.key === 'y' || (event.key === 'z' && event.shiftKey))) {
                event.preventDefault();
                redoAction();
            } else if (event.ctrlKey && event.shiftKey && event.key === 'P') {
                event.preventDefault();
                insertParagraphBreak();
            }
        });
        
        // Initial render
        view.render();
    </script>
</body>
</html>