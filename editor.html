<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multi-Stream Text Editor</title>
    <style>
        body {
            font-family: Georgia, serif;
            margin: 0;
            padding: 20px;
            background-color: #fafafa;
        }
        
        .container {
            max-width: 1000px;
            margin: 0 auto;
            background: white;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
            overflow: hidden;
        }
        
        .toolbar {
            background: #f8f9fa;
            padding: 20px 30px;
            border-bottom: 1px solid #e9ecef;
            font-size: 12px;
            color: #666;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .stream-indicator {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .stream-count {
            padding: 2px 6px;
            background: #3498db;
            color: white;
            border-radius: 3px;
            font-size: 11px;
        }
        
        .controls {
            display: flex;
            gap: 8px;
        }
        
        .btn {
            padding: 10px;
            background: transparent;
            border: none;
            border-radius: 6px;
            font-size: 16px;
            cursor: pointer;
            color: #6c757d;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 36px;
            height: 36px;
        }
        
        .btn:hover {
            background: #f8f9fa;
            color: #495057;
            transform: translateY(-1px);
        }
        
        .btn:active {
            transform: translateY(0);
            background: #e9ecef;
        }
        
        /* Custom tooltip styles */
        .btn {
            position: relative;
        }
        
        .btn::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: -35px;
            left: 50%;
            transform: translateX(-50%);
            background: #343a40;
            color: white;
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 11px;
            font-weight: 500;
            white-space: nowrap;
            opacity: 0;
            visibility: hidden;
            transition: all 0.2s ease;
            pointer-events: none;
            z-index: 1000;
        }
        
        .btn::before {
            content: '';
            position: absolute;
            bottom: -10px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 5px solid transparent;
            border-right: 5px solid transparent;
            border-bottom: 5px solid #343a40;
            opacity: 0;
            visibility: hidden;
            transition: all 0.2s ease;
            pointer-events: none;
            z-index: 1000;
        }
        
        .btn:hover::after,
        .btn:hover::before {
            opacity: 1;
            visibility: visible;
        }
        
        .title-area {
            padding: 40px 100px 20px 100px;
        }
        
        .title-input {
            width: 100%;
            border: none;
            outline: none;
            font-family: Georgia, serif;
            font-size: 28px;
            font-weight: bold;
            text-align: center;
            background: transparent;
            color: #2c3e50;
            padding: 20px 0;
            resize: none;
            overflow: hidden;
        }
        
        .title-input:focus {
            background: rgba(52, 152, 219, 0.02);
        }
        
        .title-input:empty::before {
            content: attr(data-placeholder);
            color: #bdc3c7;
            font-style: italic;
            font-weight: normal;
        }
        
        .editor-area {
            min-height: 500px;
            padding: 0;
            margin: 40px 100px 100px 100px;
        }
        
        .paragraph-group {
            position: relative;
        }
        
        .paragraph-break-header {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 60px 0 40px 0;
            padding: 20px;
            cursor: pointer;
        }
        
        .paragraph-break-symbol {
            font-size: 24px;
            color: #adb5bd;
            font-family: Georgia, serif;
            user-select: none;
            transition: all 0.2s ease;
            position: relative;
        }
        
        .paragraph-delete-indicator {
            position: absolute;
            top: -8px;
            right: -12px;
            background: #dc3545;
            color: white;
            border-radius: 50%;
            width: 16px;
            height: 16px;
            font-size: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transform: scale(0.8);
            transition: all 0.2s ease;
            font-family: monospace;
            font-weight: bold;
        }
        
        .paragraph-break-header:hover .paragraph-break-symbol {
            color: #868e96;
        }
        
        .paragraph-break-header:hover .paragraph-delete-indicator {
            opacity: 1;
            transform: scale(1);
        }
        
        .stream-chunk {
            position: relative;
            margin-bottom: 45px;
        }
        
        .stream-chunk::before {
            content: attr(data-chunk-number);
            position: absolute;
            right: 10px;
            top: 5px;
            font-size: 10px;
            color: #ccc;
            background: white;
            padding: 2px 4px;
            border-radius: 2px;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 10;
        }
        
        .stream-chunk:hover::before {
            opacity: 1;
        }
        
        .stream {
            min-height: 30px;
            padding: 0px 0px 0px 15px;
            margin-bottom: -2px;
            border: none;
            outline: none;
            font-family: Georgia, serif;
            font-size: 16px; 
            line-height: 1.6;
            resize: none;
            background: transparent;
            overflow: hidden;
            white-space: nowrap;
            width: 100%;
        }
        
        .stream:focus {
            background: rgba(52, 152, 219, 0.02);
        }
        
        .stream:empty::before {
            content: attr(data-placeholder);
            color: #999;
            font-style: italic;
        }
        
        .stream-0 { 
            color: black; 
            font-style: normal;
            border-left: 3px solid rgba(206, 205, 205, 0.3);
        }
        .stream-1 { 
            color: black;
            font-style: normal;
            border-left: 3px solid rgba(206, 205, 205, 0.3);
        }
        .stream-2 { 
            color: black; 
            font-style: normal;
            border-left: 3px solid rgba(206, 205, 205, 0.3);
        }
        .stream-3 { 
            color: black; 
            font-style: normal;
            border-left: 3px solid rgba(206, 205, 205, 0.3);
        }
        .stream-4 { 
            color: black; 
            font-style: normal;
            border-left: 3px solid rgba(206, 205, 205, 0.3);
        }
        
        .footer {
            padding: 10px 20px;
            background: #f8f9fa;
            border-top: 1px solid #e9ecef;
            font-size: 11px;
            color: #999;
        }
        
        /* Hidden measuring element */
        .text-measure {
            position: absolute;
            left: -9999px;
            top: -9999px;
            font-family: Georgia, serif;
            font-size: 16px;
            line-height: 1.6;
            white-space: nowrap;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="toolbar">
            <div class="stream-indicator">
                <span class="stream-count" id="streamCount">3</span>
                <span>streams</span>
                <span>‚Ä¢</span>
                <span id="chunkCount">1</span>
                <span>chunks</span>
            </div>
            <div class="controls">
                <button class="btn" onclick="changeStreamCount()" data-tooltip="Change Streams">‚â°</button>
                <button class="btn" onclick="insertParagraphBreak()" data-tooltip="Paragraph Break">¬∂</button>
                <button class="btn" onclick="saveFile()" data-tooltip="Save Document">üíæ</button>
                <button class="btn" onclick="loadFile()" data-tooltip="Load Document">üìÇ</button>
                <button class="btn" onclick="exportHtml()" data-tooltip="Export HTML">üåê</button>
                <button class="btn" onclick="clearAll()" data-tooltip="Clear All">üóëÔ∏è</button>
            </div>
        </div>
        
        <div class="title-area">
            <div class="title-input" 
                 contenteditable="true" 
                 data-placeholder="Enter your story title..."
                 id="titleInput">
            </div>
        </div>
        
        <div class="editor-area" id="editorArea">
            <!-- Chunks will be added here -->
        </div>
        
        <div class="footer">
            Tab for spaces ‚Ä¢ Shift+Tab to switch voices ‚Ä¢ Save/Load your work
        </div>
        
        <!-- Hidden element for text measurement -->
        <div class="text-measure" id="textMeasure"></div>
    </div>

    <script>
        // Document model - stores the actual text
        class MultiStreamDocument {
            constructor(streamCount = 3) {
                // Each paragraph group contains all streams for that section
                this.streamGroups = [new Array(streamCount).fill('')];
                this.streamCount = streamCount;
                this.activeStream = 0;
                this.activeCursor = 0;
                this.activeGroup = 0;
                this.title = '';
                this.listeners = [];
            }
            
            setStreamText(streamIndex, text, cursorPos = 0, groupIndex = null) {
                const group = groupIndex !== null ? groupIndex : this.activeGroup;
                this.streamGroups[group][streamIndex] = text;
                this.activeStream = streamIndex;
                this.activeCursor = cursorPos;
                this.activeGroup = group;
                this.notifyChange();
            }
            
            insertText(streamIndex, position, text, groupIndex = null) {
                const group = groupIndex !== null ? groupIndex : this.activeGroup;
                const stream = this.streamGroups[group][streamIndex];
                this.streamGroups[group][streamIndex] = stream.slice(0, position) + text + stream.slice(position);
                this.activeStream = streamIndex;
                this.activeCursor = position + text.length;
                this.activeGroup = group;
                this.notifyChange();
            }
            
            deleteText(streamIndex, start, end, groupIndex = null) {
                const group = groupIndex !== null ? groupIndex : this.activeGroup;
                const stream = this.streamGroups[group][streamIndex];
                this.streamGroups[group][streamIndex] = stream.slice(0, start) + stream.slice(end);
                this.activeStream = streamIndex;
                this.activeCursor = start;
                this.activeGroup = group;
                this.notifyChange();
            }
            
            insertParagraphBreak(chunkIndex) {
                // Find which group the current chunk belongs to and split there
                let targetGroupIndex = this.activeGroup;
                
                // Split each stream in the current group at the end of the specified chunk
                const currentGroup = this.streamGroups[targetGroupIndex];
                const newGroup = new Array(this.streamCount).fill('');
                
                for (let streamIndex = 0; streamIndex < this.streamCount; streamIndex++) {
                    const stream = currentGroup[streamIndex];
                    const lines = this.breakTextIntoLines(stream);
                    
                    if (chunkIndex < lines.length) {
                        // Split at the end of the chunk
                        const beforeText = lines.slice(0, chunkIndex + 1).join('');
                        const afterText = lines.slice(chunkIndex + 1).join('');
                        
                        currentGroup[streamIndex] = beforeText;
                        newGroup[streamIndex] = afterText;
                    } else {
                        // Chunk doesn't exist in this stream, leave current group unchanged
                        newGroup[streamIndex] = '';
                    }
                }
                
                // Insert the new group after the current one
                this.streamGroups.splice(targetGroupIndex + 1, 0, newGroup);
                this.notifyChange();
            }
            
            removeParagraphBreak(groupIndex) {
                // Merge the specified group with the next one
                if (groupIndex < this.streamGroups.length - 1) {
                    const currentGroup = this.streamGroups[groupIndex];
                    const nextGroup = this.streamGroups[groupIndex + 1];
                    
                    // First, calculate how many chunks the current group spans
                    const currentGroupLines = currentGroup.map(stream => this.breakTextIntoLines(stream));
                    const currentGroupMaxChunks = Math.max(...currentGroupLines.map(lines => lines.length));
                    
                    // For each stream, pad to align with the chunk boundary
                    for (let streamIndex = 0; streamIndex < this.streamCount; streamIndex++) {
                        const currentText = currentGroup[streamIndex];
                        const nextText = nextGroup[streamIndex];
                        
                        if (nextText.trim() === '') {
                            // Next group has no content for this stream, just keep current
                            continue;
                        }
                        
                        // Calculate how many chunks this stream currently fills
                        const currentLines = this.breakTextIntoLines(currentText);
                        const currentChunks = currentLines.length;
                        
                        // Calculate how much whitespace we need to add to reach the start of the next paragraph
                        let paddingNeeded = '';
                        
                        // If this stream ends before the maximum chunk count, we need to fill the gap
                        const chunksToFill = currentGroupMaxChunks - currentChunks;
                        
                        if (chunksToFill > 0) {
                            // Add spaces to fill complete empty chunks
                            // Each chunk gets filled with a single space (minimal padding)
                            paddingNeeded = ' '.repeat(chunksToFill);
                        }
                        
                        // If the last line of current text isn't empty, add a space separator
                        const lastLine = currentLines[currentLines.length - 1] || '';
                        if (lastLine.trim().length > 0) {
                            paddingNeeded += ' ';
                        }
                        
                        // Combine: current text + padding + next text
                        currentGroup[streamIndex] = currentText + paddingNeeded + nextText;
                    }
                    
                    // Remove the next group
                    this.streamGroups.splice(groupIndex + 1, 1);
                    
                    // Adjust activeGroup if necessary
                    if (this.activeGroup > groupIndex) {
                        this.activeGroup--;
                    }
                    
                    this.notifyChange();
                }
            }
            
            breakTextIntoLines(text) {
                // Use the view's method if available, otherwise return simple split
                if (window.view && window.view.breakTextIntoLines) {
                    return window.view.breakTextIntoLines(text);
                }
                return text ? [text] : [''];
            }
            
            setTitle(title) {
                this.title = title;
                // Don't trigger notifyChange for title updates to avoid re-rendering
                // Title changes don't affect the stream layout
            }
            
            onChange(callback) {
                this.listeners.push(callback);
            }
            
            notifyChange() {
                this.listeners.forEach(callback => callback());
            }
        }
        
        // View model - handles rendering and interaction
        class MultiStreamView {
            constructor(container, document) {
                this.container = container;
                this.document = document;
                this.chunks = [];
                this.maxLineWidth = 0;
                this.isUpdating = false;
                
                this.calculateMaxWidth();
                this.document.onChange(() => this.render());
                
                window.addEventListener('resize', () => {
                    this.calculateMaxWidth();
                    this.render();
                });
            }
            
            calculateMaxWidth() {
                this.maxLineWidth = this.container.clientWidth - 40; // Account for padding
            }
            
            measureTextWidth(text) {
                const measure = document.getElementById('textMeasure');
                measure.textContent = text;
                return measure.offsetWidth;
            }
            
            breakTextIntoLines(text) {
                if (!text) return [''];
                
                const lines = [];
                let currentLine = '';
                let i = 0;
                
                while (i < text.length) {
                    const char = text[i];
                    const testLine = currentLine + char;
                    const width = this.measureTextWidth(testLine);
                    
                    if (width <= this.maxLineWidth) {
                        currentLine = testLine;
                        i++;
                    } else {
                        // Line is too long, need to break
                        if (currentLine === '') {
                            // Single character is too wide, force it anyway
                            currentLine = char;
                            i++;
                        } else {
                            // Try to break at a good point
                            let breakPoint = currentLine.length;
                            
                            // Look backwards for a good break point (space or punctuation)
                            for (let j = currentLine.length - 1; j >= Math.max(0, currentLine.length - 20); j--) {
                                const c = currentLine[j];
                                if (c === ' ' || c === '\t' || c === '-' || c === '.' || c === ',') {
                                    breakPoint = j + 1;
                                    break;
                                }
                            }
                            
                            // If we found a good break point, use it
                            if (breakPoint < currentLine.length) {
                                lines.push(currentLine.substring(0, breakPoint));
                                currentLine = currentLine.substring(breakPoint);
                            } else {
                                // No good break point found, break at current position
                                lines.push(currentLine);
                                currentLine = '';
                            }
                        }
                    }
                }
                
                if (currentLine || lines.length === 0) {
                    lines.push(currentLine);
                }
                
                return lines;
            }
            
            findCursorPosition(streamIndex, absolutePosition, groupIndex) {
                const stream = this.document.streamGroups[groupIndex][streamIndex];
                const lines = this.breakTextIntoLines(stream);
                let currentPos = 0;
                
                for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {
                    const lineLength = lines[lineIndex].length;
                    if (absolutePosition <= currentPos + lineLength) {
                        return {
                            chunkIndex: lineIndex,
                            localPosition: absolutePosition - currentPos,
                            groupIndex: groupIndex
                        };
                    }
                    currentPos += lineLength;
                }
                
                return {
                    chunkIndex: lines.length - 1,
                    localPosition: lines[lines.length - 1]?.length || 0,
                    groupIndex: groupIndex
                };
            }
            
            render() {
                if (this.isUpdating) return;
                this.isUpdating = true;
                
                const activeStream = this.document.activeStream;
                const activeCursor = this.document.activeCursor;
                const activeGroup = this.document.activeGroup;
                
                // Clear and rebuild
                this.container.innerHTML = '';
                
                let totalChunks = 0;
                
                // Render each paragraph group
                for (let groupIndex = 0; groupIndex < this.document.streamGroups.length; groupIndex++) {
                    const group = this.document.streamGroups[groupIndex];
                    
                    // Break all streams in this group into lines
                    const streamLines = group.map(stream => this.breakTextIntoLines(stream));
                    const maxChunks = Math.max(...streamLines.map(lines => lines.length));
                    
                    // Create paragraph group container
                    const paragraphGroup = this.createParagraphGroup(groupIndex);
                    
                    for (let chunkIndex = 0; chunkIndex < maxChunks; chunkIndex++) {
                        const chunk = this.createChunk(totalChunks + chunkIndex + 1, groupIndex, chunkIndex);
                        
                        for (let streamIndex = 0; streamIndex < this.document.streamCount; streamIndex++) {
                            const stream = this.createStream(
                                streamIndex, 
                                chunkIndex, 
                                streamLines[streamIndex][chunkIndex] || '',
                                groupIndex
                            );
                            chunk.appendChild(stream);
                        }
                        
                        paragraphGroup.appendChild(chunk);
                    }
                    
                    this.container.appendChild(paragraphGroup);
                    totalChunks += maxChunks;
                }
                
                // Restore cursor position
                if (activeStream !== null && activeCursor !== null && activeGroup !== null) {
                    const cursorPos = this.findCursorPosition(activeStream, activeCursor, activeGroup);
                    const targetElement = this.container.querySelector(
                        `[data-stream-index="${activeStream}"][data-chunk-index="${cursorPos.chunkIndex}"][data-group-index="${activeGroup}"]`
                    );
                    
                    if (targetElement) {
                        targetElement.focus();
                        this.setCursor(targetElement, cursorPos.localPosition);
                    }
                }
                
                document.getElementById('chunkCount').textContent = totalChunks;
                this.isUpdating = false;
            }
            
            createParagraphGroup(groupIndex) {
                const paragraphGroup = document.createElement('div');
                paragraphGroup.className = 'paragraph-group';
                paragraphGroup.dataset.groupIndex = groupIndex;
                
                // Add visual indicator for paragraph breaks (except for first group)
                if (groupIndex > 0) {
                    const breakHeader = document.createElement('div');
                    breakHeader.className = 'paragraph-break-header';
                    breakHeader.title = 'Click to remove paragraph break';
                    breakHeader.onclick = () => this.removeParagraphBreakHandler(groupIndex);
                    
                    const symbol = document.createElement('span');
                    symbol.className = 'paragraph-break-symbol';
                    symbol.innerHTML = '¬ß'; // Single section symbol - classic typography
                    
                    const deleteIndicator = document.createElement('span');
                    deleteIndicator.className = 'paragraph-delete-indicator';
                    deleteIndicator.innerHTML = '√ó';
                    
                    symbol.appendChild(deleteIndicator);
                    breakHeader.appendChild(symbol);
                    
                    paragraphGroup.appendChild(breakHeader);
                }
                
                return paragraphGroup;
            }
            
            createChunk(number, groupIndex, localChunkIndex) {
                const chunk = document.createElement('div');
                chunk.className = 'stream-chunk';
                chunk.dataset.chunkNumber = number;
                chunk.dataset.groupIndex = groupIndex;
                chunk.dataset.localChunkIndex = localChunkIndex;
                return chunk;
            }
            
            createStream(streamIndex, chunkIndex, text, groupIndex) {
                const stream = document.createElement('div');
                stream.className = `stream stream-${streamIndex}`;
                stream.contentEditable = true;
                stream.dataset.streamIndex = streamIndex;
                stream.dataset.chunkIndex = chunkIndex;
                stream.dataset.groupIndex = groupIndex;
                stream.textContent = text;
                
                if (streamIndex === 0 && chunkIndex === 0 && groupIndex === 0 && !text) {
                    stream.dataset.placeholder = 'Start writing your multi-stream story...';
                }
                
                stream.addEventListener('input', (e) => this.handleInput(e, streamIndex, groupIndex));
                stream.addEventListener('keydown', (e) => this.handleKeyDown(e, streamIndex, chunkIndex, groupIndex));
                stream.addEventListener('focus', (e) => {
                    lastFocusedElement = e.target;
                });
                
                return stream;
            }
            
            handleInput(event, streamIndex, groupIndex) {
                if (this.isUpdating) return;
                
                const element = event.target;
                const cursorPos = this.getCursorPosition(element);
                const chunkIndex = parseInt(element.dataset.chunkIndex);
                
                // Reconstruct the full text for this stream in this group
                const chunks = Array.from(this.container.querySelectorAll(
                    `[data-stream-index="${streamIndex}"][data-group-index="${groupIndex}"]`
                ));
                let absolutePosition = 0;
                
                // Calculate absolute cursor position
                for (let i = 0; i < chunkIndex; i++) {
                    if (chunks[i]) {
                        absolutePosition += chunks[i].textContent.length;
                    }
                }
                absolutePosition += cursorPos;
                
                // Get full text for this stream in this group
                const fullText = chunks.map(chunk => chunk.textContent).join('');
                
                // Update document
                this.document.setStreamText(streamIndex, fullText, absolutePosition, groupIndex);
            }
            
            handleKeyDown(event, streamIndex, chunkIndex, groupIndex) {
                if (event.key === 'Tab') {
                    event.preventDefault();
                    
                    if (event.shiftKey) {
                        // Shift+Tab: switch to previous voice
                        const prevStreamIndex = (streamIndex - 1 + this.document.streamCount) % this.document.streamCount;
                        const prevElement = this.container.querySelector(
                            `[data-stream-index="${prevStreamIndex}"][data-chunk-index="${chunkIndex}"][data-group-index="${groupIndex}"]`
                        );
                        if (prevElement) {
                            prevElement.focus();
                        }
                    } else {
                        // Regular Tab: insert 4 spaces using execCommand for simplicity
                        document.execCommand('insertText', false, '            ');
                    }
                }
            }
            
            getCursorPosition(element) {
                const selection = window.getSelection();
                if (selection.rangeCount === 0) return 0;
                const range = selection.getRangeAt(0);
                return range.startOffset;
            }
            
            setCursor(element, position) {
                const range = document.createRange();
                const selection = window.getSelection();
                
                if (element.firstChild) {
                    range.setStart(element.firstChild, Math.min(position, element.firstChild.textContent.length));
                } else {
                    range.setStart(element, 0);
                }
                
                range.collapse(true);
                selection.removeAllRanges();
                selection.addRange(range);
            }
            
            removeParagraphBreakHandler(groupIndex) {
                // Confirm before removing
                if (confirm('Remove this paragraph break? The content will be merged with the paragraph above.')) {
                    // Remove the paragraph break (merge with previous group)
                    this.document.removeParagraphBreak(groupIndex - 1);
                }
            }
        }
        
        // Initialize the editor
        const doc = new MultiStreamDocument(3);
        const view = new MultiStreamView(document.getElementById('editorArea'), doc);
        
        // Make view available globally for document model to use
        window.view = view;
        
        // Track the last focused text element
        let lastFocusedElement = null;
        
        // Handle title input
        const titleInput = document.getElementById('titleInput');
        titleInput.addEventListener('input', function() {
            doc.setTitle(this.textContent);
        });
        
        titleInput.addEventListener('focus', function() {
            // Don't set lastFocusedElement for title, keep it for stream elements
        });
        
        // Global functions for UI
        function insertParagraphBreak() {
            // Use the last focused element or try to find the current one
            const focusedElement = lastFocusedElement || document.activeElement;
            
            if (!focusedElement || !focusedElement.dataset || !focusedElement.dataset.chunkIndex) {
                // If no element is focused, try to use the first text area
                const firstTextArea = document.querySelector('[data-stream-index="0"][data-group-index="0"][data-chunk-index="0"]');
                if (firstTextArea) {
                    lastFocusedElement = firstTextArea;
                } else {
                    alert('Please click in a text area first');
                    return;
                }
            }
            
            const targetElement = lastFocusedElement;
            const chunkIndex = parseInt(targetElement.dataset.chunkIndex);
            const groupIndex = parseInt(targetElement.dataset.groupIndex);
            
            // Set the active group to the current group
            doc.activeGroup = groupIndex;
            
            // Insert paragraph break at the end of this chunk
            doc.insertParagraphBreak(chunkIndex);
        }
        
        function changeStreamCount() {
            const currentCount = doc.streamCount;
            const options = [2, 3, 4, 5];
            
            // Create a simple selection dialog
            const dialog = document.createElement('div');
            dialog.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.5);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 1000;
            `;
            
            const content = document.createElement('div');
            content.style.cssText = `
                background: white;
                padding: 30px;
                border-radius: 8px;
                box-shadow: 0 4px 20px rgba(0,0,0,0.3);
                text-align: center;
                max-width: 400px;
            `;
            
            content.innerHTML = `
                <h3 style="margin: 0 0 20px 0; color: #2c3e50;">Choose Number of Voices</h3>
                <p style="margin: 0 0 25px 0; color: #666;">Select how many different voices you want in your story:</p>
                <div style="display: flex; gap: 10px; justify-content: center; margin-bottom: 25px;">
                    ${options.map(num => `
                        <button onclick="selectStreamCount(${num})" 
                                style="
                                    padding: 15px 20px;
                                    border: 2px solid ${num === currentCount ? '#3498db' : '#ddd'};
                                    background: ${num === currentCount ? '#3498db' : 'white'};
                                    color: ${num === currentCount ? 'white' : '#666'};
                                    border-radius: 6px;
                                    cursor: pointer;
                                    font-size: 16px;
                                    font-weight: bold;
                                    transition: all 0.2s;
                                "
                                onmouseover="this.style.borderColor='#3498db'; this.style.background='${num === currentCount ? '#3498db' : '#f8f9fa'}';"
                                onmouseout="this.style.borderColor='${num === currentCount ? '#3498db' : '#ddd'}'; this.style.background='${num === currentCount ? '#3498db' : 'white'}';">
                            ${num}
                        </button>
                    `).join('')}
                </div>
                <button onclick="closeStreamDialog()" 
                        style="
                            padding: 10px 20px;
                            border: 1px solid #ddd;
                            background: #f8f9fa;
                            color: #666;
                            border-radius: 4px;
                            cursor: pointer;
                        ">
                    Cancel
                </button>
            `;
            
            dialog.appendChild(content);
            document.body.appendChild(dialog);
            
            // Store dialog reference for cleanup
            window.currentStreamDialog = dialog;
        }
        
        function selectStreamCount(newCount) {
            if (newCount >= 2 && newCount <= 5) {
                const oldGroups = doc.streamGroups.map(group => group.slice());
                doc.streamCount = newCount;
                
                // Resize each group to the new stream count
                doc.streamGroups = oldGroups.map(oldGroup => {
                    const newGroup = new Array(newCount).fill('');
                    // Copy over existing streams
                    for (let i = 0; i < Math.min(oldGroup.length, newCount); i++) {
                        newGroup[i] = oldGroup[i];
                    }
                    return newGroup;
                });
                
                document.getElementById('streamCount').textContent = newCount;
                view.render();
                closeStreamDialog();
            }
        }
        
        function closeStreamDialog() {
            if (window.currentStreamDialog) {
                document.body.removeChild(window.currentStreamDialog);
                window.currentStreamDialog = null;
            }
        }
        
        function saveFile() {
            const now = new Date().toISOString().split('T')[0];
            const title = doc.title || 'Untitled Story';
            
            // Create the file content
            let content = `---
streams: ${doc.streamCount}
title: "${title}"
created: "${now}"
version: "1.0"
---

`;
            
            // Save each paragraph group
            for (let groupIndex = 0; groupIndex < doc.streamGroups.length; groupIndex++) {
                const group = doc.streamGroups[groupIndex];
                content += `=== Paragraph ${groupIndex + 1} ===\n`;
                
                // Find all chunks by breaking streams into lines
                const streamLines = group.map(stream => view.breakTextIntoLines(stream));
                const maxChunks = Math.max(...streamLines.map(lines => lines.length));
                
                for (let chunkIndex = 0; chunkIndex < maxChunks; chunkIndex++) {
                    content += `--- Chunk ${chunkIndex + 1} ---\n`;
                    for (let streamIndex = 0; streamIndex < doc.streamCount; streamIndex++) {
                        const line = streamLines[streamIndex][chunkIndex] || '';
                        if (line.trim()) {
                            content += `Stream ${streamIndex + 1}: ${line}\n`;
                        }
                    }
                    content += '\n';
                }
                content += '\n';
            }
            
            // Download the file
            const blob = new Blob([content], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${title.replace(/[^a-z0-9]/gi, '_')}.txt`;
            a.click();
            URL.revokeObjectURL(url);
        }
        
        function loadFile() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.txt';
            
            input.onchange = function(e) {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        parseAndLoadFile(e.target.result);
                    } catch (error) {
                        alert('Error loading file: ' + error.message);
                    }
                };
                reader.readAsText(file);
            };
            
            input.click();
        }
        
        function parseAndLoadFile(content) {
            const lines = content.split('\n');
            let inMetadata = false;
            let inContent = false;
            let metadata = {};
            let currentParagraph = null;
            let currentChunk = null;
            let paragraphs = [];
            
            for (const line of lines) {
                const trimmed = line.trim();
                
                if (trimmed === '---') {
                    if (!inMetadata) {
                        inMetadata = true;
                    } else {
                        inMetadata = false;
                        inContent = true;
                    }
                    continue;
                }
                
                if (inMetadata) {
                    const [key, ...valueParts] = trimmed.split(':');
                    if (key && valueParts.length > 0) {
                        const value = valueParts.join(':').trim().replace(/"/g, '');
                        metadata[key.trim()] = value;
                    }
                }
                
                if (inContent) {
                    if (trimmed.startsWith('=== Paragraph')) {
                        if (currentParagraph) {
                            if (currentChunk) currentParagraph.push(currentChunk);
                            paragraphs.push(currentParagraph);
                        }
                        currentParagraph = [];
                        currentChunk = null;
                    } else if (trimmed.startsWith('--- Chunk') || trimmed.startsWith('=== Chunk')) {
                        if (currentChunk) currentParagraph.push(currentChunk);
                        currentChunk = {};
                    } else if (trimmed.startsWith('Stream ')) {
                        const match = trimmed.match(/^Stream (\d+): (.*)$/);
                        if (match && currentChunk) {
                            const streamIndex = parseInt(match[1]) - 1;
                            currentChunk[streamIndex] = match[2];
                        }
                    }
                }
            }
            
            // Handle final chunk and paragraph
            if (currentChunk) currentParagraph.push(currentChunk);
            if (currentParagraph) paragraphs.push(currentParagraph);
            
            // Reconstruct stream groups
            const streamCount = parseInt(metadata.streams) || 3;
            const newStreamGroups = [];
            
            for (let paragraphIndex = 0; paragraphIndex < paragraphs.length; paragraphIndex++) {
                const chunks = paragraphs[paragraphIndex];
                const groupStreams = new Array(streamCount).fill('');
                
                for (let streamIndex = 0; streamIndex < streamCount; streamIndex++) {
                    const streamParts = chunks
                        .map(chunk => chunk[streamIndex] || '')
                        .filter((part, index, arr) => {
                            // Remove empty parts at the end
                            const lastNonEmpty = arr.map((p, i) => p ? i : -1).filter(i => i >= 0).pop();
                            return index <= lastNonEmpty || part;
                        });
                    groupStreams[streamIndex] = streamParts.join('');
                }
                
                newStreamGroups.push(groupStreams);
            }
            
            // Ensure at least one group exists
            if (newStreamGroups.length === 0) {
                newStreamGroups.push(new Array(streamCount).fill(''));
            }
            
            // Update document
            doc.streamCount = streamCount;
            doc.streamGroups = newStreamGroups;
            doc.title = metadata.title || '';
            doc.activeStream = 0;
            doc.activeCursor = 0;
            doc.activeGroup = 0;
            
            // Update title input
            document.getElementById('titleInput').textContent = doc.title;
            
            document.getElementById('streamCount').textContent = streamCount;
            doc.notifyChange();
            
            alert(`Loaded "${metadata.title || 'Untitled'}" with ${streamCount} streams and ${newStreamGroups.length} paragraphs`);
        }
        
        function exportHtml() {
            const title = doc.title || 'Multi-Voice Story';
            
            // Generate HTML similar to our display format
            let html = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${title}</title>
    <style>
        body { font-family: Georgia, serif; max-width: 800px; margin: 0 auto; padding: 20px; line-height: 1.6; }
        h1 { text-align: center; color: #2c3e50; }
        .stream-chunk { margin-bottom: 30px; border-bottom: 1px solid #eee; padding-bottom: 20px; }
        .stream { padding: 10px 15px; margin-bottom: 5px; }
        .stream-0 { color: #8B4513; font-style: italic; border-left: 3px solid rgba(139, 69, 19, 0.3); }
        .stream-1 { color: #2c3e50; border-left: 3px solid rgba(44, 62, 80, 0.3); }
        .stream-2 { color: #4682B4; font-style: italic; border-left: 3px solid rgba(70, 130, 180, 0.3); }
        .stream-3 { color: #27AE60; font-style: italic; border-left: 3px solid rgba(39, 174, 96, 0.3); }
        .stream-4 { color: #E74C3C; font-style: italic; border-left: 3px solid rgba(231, 76, 60, 0.3); }
    </style>
</head>
<body>
    <h1>${title}</h1>
`;
            
            for (let groupIndex = 0; groupIndex < doc.streamGroups.length; groupIndex++) {
                const group = doc.streamGroups[groupIndex];
                
                if (groupIndex > 0) {
                    html += '    <div class="paragraph-break"></div>\n';
                }
                
                const streamLines = group.map(stream => view.breakTextIntoLines(stream));
                const maxChunks = Math.max(...streamLines.map(lines => lines.length));
                
                for (let chunkIndex = 0; chunkIndex < maxChunks; chunkIndex++) {
                    html += '    <div class="stream-chunk">\n';
                    for (let streamIndex = 0; streamIndex < doc.streamCount; streamIndex++) {
                        const line = streamLines[streamIndex][chunkIndex] || '';
                        if (line.trim()) {
                            html += `        <div class="stream stream-${streamIndex}">${line}</div>\n`;
                        }
                    }
                    html += '    </div>\n';
                }
            }
            
            html += `</body>
</html>`;
            
            const blob = new Blob([html], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${title.replace(/[^a-z0-9]/gi, '_')}.html`;
            a.click();
            URL.revokeObjectURL(url);
        }
        
        function exportLatex() {
            const title = doc.title || 'Multi-Voice Story';
            
            let latex = `\\documentclass[11pt]{article}
\\usepackage[margin=1in]{geometry}
\\usepackage{paracol}
\\usepackage{xcolor}

\\title{${title}}
\\author{Your Name}
\\date{}

% Define colors for each voice
\\definecolor{voice1color}{RGB}{139,69,19}
\\definecolor{voice2color}{RGB}{44,62,80}
\\definecolor{voice3color}{RGB}{70,130,180}
\\definecolor{voice4color}{RGB}{39,174,96}
\\definecolor{voice5color}{RGB}{231,76,60}

% Commands for each voice
\\newcommand{\\voiceone}[1]{\\textcolor{voice1color}{\\textit{#1}}}
\\newcommand{\\voicetwo}[1]{\\textcolor{voice2color}{#1}}
\\newcommand{\\voicethree}[1]{\\textcolor{voice3color}{\\textit{#1}}}
\\newcommand{\\voicefour}[1]{\\textcolor{voice4color}{\\textit{#1}}}
\\newcommand{\\voicefive}[1]{\\textcolor{voice5color}{\\textit{#1}}}

\\begin{document}
\\maketitle

\\begin{paracol}{${doc.streamCount}}

`;
            
            for (let groupIndex = 0; groupIndex < doc.streamGroups.length; groupIndex++) {
                const group = doc.streamGroups[groupIndex];
                
                if (groupIndex > 0) {
                    latex += '\n\\switchcolumn*\n\\vspace{20pt}\n\\switchcolumn*\n\n';
                }
                
                const streamLines = group.map(stream => view.breakTextIntoLines(stream));
                const maxChunks = Math.max(...streamLines.map(lines => lines.length));
                
                for (let chunkIndex = 0; chunkIndex < maxChunks; chunkIndex++) {
                    for (let streamIndex = 0; streamIndex < doc.streamCount; streamIndex++) {
                        const line = streamLines[streamIndex][chunkIndex] || '';
                        const commands = ['\\voiceone', '\\voicetwo', '\\voicethree', '\\voicefour', '\\voicefive'];
                        const command = commands[streamIndex] || '\\voicetwo';
                        
                        if (line.trim()) {
                            latex += `${command}{${line.replace(/&/g, '\\&').replace(/#/g, '\\#')}}\n`;
                        }
                        
                        if (streamIndex < doc.streamCount - 1) {
                            latex += '\\switchcolumn\n';
                        }
                    }
                    
                    if (chunkIndex < maxChunks - 1) {
                        latex += '\n\\switchcolumn*\n\n';
                    }
                }
            }
            
            latex += `

\\end{paracol}
\\end{document}`;
            
            const blob = new Blob([latex], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${title.replace(/[^a-z0-9]/gi, '_')}.tex`;
            a.click();
            URL.revokeObjectURL(url);
        }
        
        function clearAll() {
            if (confirm('Clear all content? This cannot be undone.')) {
                doc.streamGroups = [new Array(doc.streamCount).fill('')];
                doc.title = '';
                doc.activeStream = 0;
                doc.activeCursor = 0;
                doc.activeGroup = 0;
                
                // Clear title input
                document.getElementById('titleInput').textContent = '';
                
                doc.notifyChange();
            }
        }
        
        // Initialize
        document.getElementById('streamCount').textContent = doc.streamCount;
        view.render();
    </script>
</body>
</html>
